/*
===========================================================================

HLML.

MIT License

Copyright (c) 2019 Dan Moody

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

===========================================================================
*/

// THIS FILE WAS AUTOMATICALLY GENERATED BY A TOOL.
// EDITING THIS FILE MAY CAUSE SIDE EFFECTS.
// DO SO AT YOUR OWN RISK.

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#include "hlml_defines.h"

#include "bool2.h"
#include "bool3.h"
#include "bool4.h"
#include "int2.h"
#include "int3.h"
#include "int4.h"
#include "uint2.h"
#include "uint3.h"
#include "uint4.h"
#include "float2.h"
#include "float3.h"
#include "float4.h"
#include "double2.h"
#include "double3.h"
#include "double4.h"

#include "hlml_functions_scalar.h"

// bool2
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool bool2_equals( const bool2* lhs, const bool2* rhs )
{
	return
		lhs->x == rhs->x &&
		lhs->y == rhs->y;
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool bool2_not_equals( const bool2* lhs, const bool2* rhs )
{
	return !bool2_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two vectors and returns the result.
HLML_INLINE bool2 bool2_less_than( const bool2* lhs, const bool2* rhs )
{
	return HLML_CONSTRUCT( bool2 )
	{
		lhs->x < rhs->x,
		lhs->y < rhs->y
	};
}

// Performs a component-wise '<=' check against the two vectors and returns the result.
HLML_INLINE bool2 bool2_less_than_equal( const bool2* lhs, const bool2* rhs )
{
	return HLML_CONSTRUCT( bool2 )
	{
		lhs->x <= rhs->x,
		lhs->y <= rhs->y
	};
}

// Performs a component-wise '>' check against the two vectors and returns the result.
HLML_INLINE bool2 bool2_greater_than( const bool2* lhs, const bool2* rhs )
{
	return HLML_CONSTRUCT( bool2 )
	{
		lhs->x > rhs->x,
		lhs->y > rhs->y
	};
}

// Performs a component-wise '>=' check against the two vectors and returns the result.
HLML_INLINE bool2 bool2_greater_than_equal( const bool2* lhs, const bool2* rhs )
{
	return HLML_CONSTRUCT( bool2 )
	{
		lhs->x >= rhs->x,
		lhs->y >= rhs->y
	};
}

// Performs a component-wise + on the vector by the scalar and returns the result.
HLML_INLINE bool2 bool2_cadds( const bool2* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool2 )
	{
		lhs->x + rhs,
		lhs->y + rhs
	};
}

// Performs a component-wise + against the two vectors and returns the result.
HLML_INLINE bool2 bool2_caddv( const bool2* lhs, const bool2* rhs )
{
	return HLML_CONSTRUCT( bool2 )
	{
		lhs->x + rhs->x,
		lhs->y + rhs->y
	};
}

// Performs a component-wise - on the vector by the scalar and returns the result.
HLML_INLINE bool2 bool2_csubs( const bool2* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool2 )
	{
		lhs->x - rhs,
		lhs->y - rhs
	};
}

// Performs a component-wise - against the two vectors and returns the result.
HLML_INLINE bool2 bool2_csubv( const bool2* lhs, const bool2* rhs )
{
	return HLML_CONSTRUCT( bool2 )
	{
		lhs->x - rhs->x,
		lhs->y - rhs->y
	};
}

// Performs a component-wise * on the vector by the scalar and returns the result.
HLML_INLINE bool2 bool2_cmuls( const bool2* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool2 )
	{
		lhs->x * rhs,
		lhs->y * rhs
	};
}

// Performs a component-wise * against the two vectors and returns the result.
HLML_INLINE bool2 bool2_cmulv( const bool2* lhs, const bool2* rhs )
{
	return HLML_CONSTRUCT( bool2 )
	{
		lhs->x * rhs->x,
		lhs->y * rhs->y
	};
}

// Performs a component-wise / on the vector by the scalar and returns the result.
HLML_INLINE bool2 bool2_cdivs( const bool2* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool2 )
	{
		lhs->x / rhs,
		lhs->y / rhs
	};
}

// Performs a component-wise / against the two vectors and returns the result.
HLML_INLINE bool2 bool2_cdivv( const bool2* lhs, const bool2* rhs )
{
	return HLML_CONSTRUCT( bool2 )
	{
		lhs->x / rhs->x,
		lhs->y / rhs->y
	};
}

// Returns true if ALL components of the 'x' are true, otherwise returns false.
HLML_INLINE bool bool2_all( const bool2* x )
{
	return x->x && x->y;
}

// Returns true if ANY one component of 'x' is true, otherwise returns false.
HLML_INLINE bool bool2_any( const bool2* x )
{
	return x->x || x->y;
}

// bool3
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool bool3_equals( const bool3* lhs, const bool3* rhs )
{
	return
		lhs->x == rhs->x &&
		lhs->y == rhs->y &&
		lhs->z == rhs->z;
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool bool3_not_equals( const bool3* lhs, const bool3* rhs )
{
	return !bool3_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two vectors and returns the result.
HLML_INLINE bool3 bool3_less_than( const bool3* lhs, const bool3* rhs )
{
	return HLML_CONSTRUCT( bool3 )
	{
		lhs->x < rhs->x,
		lhs->y < rhs->y,
		lhs->z < rhs->z
	};
}

// Performs a component-wise '<=' check against the two vectors and returns the result.
HLML_INLINE bool3 bool3_less_than_equal( const bool3* lhs, const bool3* rhs )
{
	return HLML_CONSTRUCT( bool3 )
	{
		lhs->x <= rhs->x,
		lhs->y <= rhs->y,
		lhs->z <= rhs->z
	};
}

// Performs a component-wise '>' check against the two vectors and returns the result.
HLML_INLINE bool3 bool3_greater_than( const bool3* lhs, const bool3* rhs )
{
	return HLML_CONSTRUCT( bool3 )
	{
		lhs->x > rhs->x,
		lhs->y > rhs->y,
		lhs->z > rhs->z
	};
}

// Performs a component-wise '>=' check against the two vectors and returns the result.
HLML_INLINE bool3 bool3_greater_than_equal( const bool3* lhs, const bool3* rhs )
{
	return HLML_CONSTRUCT( bool3 )
	{
		lhs->x >= rhs->x,
		lhs->y >= rhs->y,
		lhs->z >= rhs->z
	};
}

// Performs a component-wise + on the vector by the scalar and returns the result.
HLML_INLINE bool3 bool3_cadds( const bool3* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool3 )
	{
		lhs->x + rhs,
		lhs->y + rhs,
		lhs->z + rhs
	};
}

// Performs a component-wise + against the two vectors and returns the result.
HLML_INLINE bool3 bool3_caddv( const bool3* lhs, const bool3* rhs )
{
	return HLML_CONSTRUCT( bool3 )
	{
		lhs->x + rhs->x,
		lhs->y + rhs->y,
		lhs->z + rhs->z
	};
}

// Performs a component-wise - on the vector by the scalar and returns the result.
HLML_INLINE bool3 bool3_csubs( const bool3* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool3 )
	{
		lhs->x - rhs,
		lhs->y - rhs,
		lhs->z - rhs
	};
}

// Performs a component-wise - against the two vectors and returns the result.
HLML_INLINE bool3 bool3_csubv( const bool3* lhs, const bool3* rhs )
{
	return HLML_CONSTRUCT( bool3 )
	{
		lhs->x - rhs->x,
		lhs->y - rhs->y,
		lhs->z - rhs->z
	};
}

// Performs a component-wise * on the vector by the scalar and returns the result.
HLML_INLINE bool3 bool3_cmuls( const bool3* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool3 )
	{
		lhs->x * rhs,
		lhs->y * rhs,
		lhs->z * rhs
	};
}

// Performs a component-wise * against the two vectors and returns the result.
HLML_INLINE bool3 bool3_cmulv( const bool3* lhs, const bool3* rhs )
{
	return HLML_CONSTRUCT( bool3 )
	{
		lhs->x * rhs->x,
		lhs->y * rhs->y,
		lhs->z * rhs->z
	};
}

// Performs a component-wise / on the vector by the scalar and returns the result.
HLML_INLINE bool3 bool3_cdivs( const bool3* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool3 )
	{
		lhs->x / rhs,
		lhs->y / rhs,
		lhs->z / rhs
	};
}

// Performs a component-wise / against the two vectors and returns the result.
HLML_INLINE bool3 bool3_cdivv( const bool3* lhs, const bool3* rhs )
{
	return HLML_CONSTRUCT( bool3 )
	{
		lhs->x / rhs->x,
		lhs->y / rhs->y,
		lhs->z / rhs->z
	};
}

// Returns true if ALL components of the 'x' are true, otherwise returns false.
HLML_INLINE bool bool3_all( const bool3* x )
{
	return x->x && x->y && x->z;
}

// Returns true if ANY one component of 'x' is true, otherwise returns false.
HLML_INLINE bool bool3_any( const bool3* x )
{
	return x->x || x->y || x->z;
}

// bool4
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool bool4_equals( const bool4* lhs, const bool4* rhs )
{
	return
		lhs->x == rhs->x &&
		lhs->y == rhs->y &&
		lhs->z == rhs->z &&
		lhs->w == rhs->w;
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool bool4_not_equals( const bool4* lhs, const bool4* rhs )
{
	return !bool4_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two vectors and returns the result.
HLML_INLINE bool4 bool4_less_than( const bool4* lhs, const bool4* rhs )
{
	return HLML_CONSTRUCT( bool4 )
	{
		lhs->x < rhs->x,
		lhs->y < rhs->y,
		lhs->z < rhs->z,
		lhs->w < rhs->w
	};
}

// Performs a component-wise '<=' check against the two vectors and returns the result.
HLML_INLINE bool4 bool4_less_than_equal( const bool4* lhs, const bool4* rhs )
{
	return HLML_CONSTRUCT( bool4 )
	{
		lhs->x <= rhs->x,
		lhs->y <= rhs->y,
		lhs->z <= rhs->z,
		lhs->w <= rhs->w
	};
}

// Performs a component-wise '>' check against the two vectors and returns the result.
HLML_INLINE bool4 bool4_greater_than( const bool4* lhs, const bool4* rhs )
{
	return HLML_CONSTRUCT( bool4 )
	{
		lhs->x > rhs->x,
		lhs->y > rhs->y,
		lhs->z > rhs->z,
		lhs->w > rhs->w
	};
}

// Performs a component-wise '>=' check against the two vectors and returns the result.
HLML_INLINE bool4 bool4_greater_than_equal( const bool4* lhs, const bool4* rhs )
{
	return HLML_CONSTRUCT( bool4 )
	{
		lhs->x >= rhs->x,
		lhs->y >= rhs->y,
		lhs->z >= rhs->z,
		lhs->w >= rhs->w
	};
}

// Performs a component-wise + on the vector by the scalar and returns the result.
HLML_INLINE bool4 bool4_cadds( const bool4* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool4 )
	{
		lhs->x + rhs,
		lhs->y + rhs,
		lhs->z + rhs,
		lhs->w + rhs
	};
}

// Performs a component-wise + against the two vectors and returns the result.
HLML_INLINE bool4 bool4_caddv( const bool4* lhs, const bool4* rhs )
{
	return HLML_CONSTRUCT( bool4 )
	{
		lhs->x + rhs->x,
		lhs->y + rhs->y,
		lhs->z + rhs->z,
		lhs->w + rhs->w
	};
}

// Performs a component-wise - on the vector by the scalar and returns the result.
HLML_INLINE bool4 bool4_csubs( const bool4* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool4 )
	{
		lhs->x - rhs,
		lhs->y - rhs,
		lhs->z - rhs,
		lhs->w - rhs
	};
}

// Performs a component-wise - against the two vectors and returns the result.
HLML_INLINE bool4 bool4_csubv( const bool4* lhs, const bool4* rhs )
{
	return HLML_CONSTRUCT( bool4 )
	{
		lhs->x - rhs->x,
		lhs->y - rhs->y,
		lhs->z - rhs->z,
		lhs->w - rhs->w
	};
}

// Performs a component-wise * on the vector by the scalar and returns the result.
HLML_INLINE bool4 bool4_cmuls( const bool4* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool4 )
	{
		lhs->x * rhs,
		lhs->y * rhs,
		lhs->z * rhs,
		lhs->w * rhs
	};
}

// Performs a component-wise * against the two vectors and returns the result.
HLML_INLINE bool4 bool4_cmulv( const bool4* lhs, const bool4* rhs )
{
	return HLML_CONSTRUCT( bool4 )
	{
		lhs->x * rhs->x,
		lhs->y * rhs->y,
		lhs->z * rhs->z,
		lhs->w * rhs->w
	};
}

// Performs a component-wise / on the vector by the scalar and returns the result.
HLML_INLINE bool4 bool4_cdivs( const bool4* lhs, const bool32_t rhs )
{
	return HLML_CONSTRUCT( bool4 )
	{
		lhs->x / rhs,
		lhs->y / rhs,
		lhs->z / rhs,
		lhs->w / rhs
	};
}

// Performs a component-wise / against the two vectors and returns the result.
HLML_INLINE bool4 bool4_cdivv( const bool4* lhs, const bool4* rhs )
{
	return HLML_CONSTRUCT( bool4 )
	{
		lhs->x / rhs->x,
		lhs->y / rhs->y,
		lhs->z / rhs->z,
		lhs->w / rhs->w
	};
}

// Returns true if ALL components of the 'x' are true, otherwise returns false.
HLML_INLINE bool bool4_all( const bool4* x )
{
	return x->x && x->y && x->z && x->w;
}

// Returns true if ANY one component of 'x' is true, otherwise returns false.
HLML_INLINE bool bool4_any( const bool4* x )
{
	return x->x || x->y || x->z || x->w;
}

// int2
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool int2_equals( const int2* lhs, const int2* rhs )
{
	return
		lhs->x == rhs->x &&
		lhs->y == rhs->y;
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool int2_not_equals( const int2* lhs, const int2* rhs )
{
	return !int2_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two vectors and returns the result.
HLML_INLINE bool2 int2_less_than( const int2* lhs, const int2* rhs )
{
	return HLML_CONSTRUCT( bool2 )
	{
		lhs->x < rhs->x,
		lhs->y < rhs->y
	};
}

// Performs a component-wise '<=' check against the two vectors and returns the result.
HLML_INLINE bool2 int2_less_than_equal( const int2* lhs, const int2* rhs )
{
	return HLML_CONSTRUCT( bool2 )
	{
		lhs->x <= rhs->x,
		lhs->y <= rhs->y
	};
}

// Performs a component-wise '>' check against the two vectors and returns the result.
HLML_INLINE bool2 int2_greater_than( const int2* lhs, const int2* rhs )
{
	return HLML_CONSTRUCT( bool2 )
	{
		lhs->x > rhs->x,
		lhs->y > rhs->y
	};
}

// Performs a component-wise '>=' check against the two vectors and returns the result.
HLML_INLINE bool2 int2_greater_than_equal( const int2* lhs, const int2* rhs )
{
	return HLML_CONSTRUCT( bool2 )
	{
		lhs->x >= rhs->x,
		lhs->y >= rhs->y
	};
}

// Performs a component-wise + on the vector by the scalar and returns the result.
HLML_INLINE int2 int2_cadds( const int2* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int2 )
	{
		lhs->x + rhs,
		lhs->y + rhs
	};
}

// Performs a component-wise + against the two vectors and returns the result.
HLML_INLINE int2 int2_caddv( const int2* lhs, const int2* rhs )
{
	return HLML_CONSTRUCT( int2 )
	{
		lhs->x + rhs->x,
		lhs->y + rhs->y
	};
}

// Performs a component-wise - on the vector by the scalar and returns the result.
HLML_INLINE int2 int2_csubs( const int2* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int2 )
	{
		lhs->x - rhs,
		lhs->y - rhs
	};
}

// Performs a component-wise - against the two vectors and returns the result.
HLML_INLINE int2 int2_csubv( const int2* lhs, const int2* rhs )
{
	return HLML_CONSTRUCT( int2 )
	{
		lhs->x - rhs->x,
		lhs->y - rhs->y
	};
}

// Performs a component-wise * on the vector by the scalar and returns the result.
HLML_INLINE int2 int2_cmuls( const int2* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int2 )
	{
		lhs->x * rhs,
		lhs->y * rhs
	};
}

// Performs a component-wise * against the two vectors and returns the result.
HLML_INLINE int2 int2_cmulv( const int2* lhs, const int2* rhs )
{
	return HLML_CONSTRUCT( int2 )
	{
		lhs->x * rhs->x,
		lhs->y * rhs->y
	};
}

// Performs a component-wise / on the vector by the scalar and returns the result.
HLML_INLINE int2 int2_cdivs( const int2* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int2 )
	{
		lhs->x / rhs,
		lhs->y / rhs
	};
}

// Performs a component-wise / against the two vectors and returns the result.
HLML_INLINE int2 int2_cdivv( const int2* lhs, const int2* rhs )
{
	return HLML_CONSTRUCT( int2 )
	{
		lhs->x / rhs->x,
		lhs->y / rhs->y
	};
}

// Returns a copy of the vector where each component has been bitwise NOT'd.
HLML_INLINE int2 int2_unary( const int2* x )
{
	return HLML_CONSTRUCT( int2 )
	{
		~x->x,
		~x->y
	};
}

// Performs a component-wise bitwise & on the vector by the scalar and returns the result.
HLML_INLINE int2 int2_cands( const int2* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int2 )
	{
		lhs->x & rhs,
		lhs->y & rhs
	};
}

// Performs a component-wise bitwise & against the two vectors and returns the result.
HLML_INLINE int2 int2_candv( const int2* lhs, const int2* rhs )
{
	return HLML_CONSTRUCT( int2 )
	{
		lhs->x & rhs->x,
		lhs->y & rhs->y
	};
}

// Performs a component-wise bitwise | on the vector by the scalar and returns the result.
HLML_INLINE int2 int2_cors( const int2* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int2 )
	{
		lhs->x | rhs,
		lhs->y | rhs
	};
}

// Performs a component-wise bitwise | against the two vectors and returns the result.
HLML_INLINE int2 int2_corv( const int2* lhs, const int2* rhs )
{
	return HLML_CONSTRUCT( int2 )
	{
		lhs->x | rhs->x,
		lhs->y | rhs->y
	};
}

// Performs a component-wise bitwise ^ on the vector by the scalar and returns the result.
HLML_INLINE int2 int2_cxors( const int2* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int2 )
	{
		lhs->x ^ rhs,
		lhs->y ^ rhs
	};
}

// Performs a component-wise bitwise ^ against the two vectors and returns the result.
HLML_INLINE int2 int2_cxorv( const int2* lhs, const int2* rhs )
{
	return HLML_CONSTRUCT( int2 )
	{
		lhs->x ^ rhs->x,
		lhs->y ^ rhs->y
	};
}

// Performs a component-wise bitwise << on the vector by the scalar and returns the result.
HLML_INLINE int2 int2_cshift_lefts( const int2* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int2 )
	{
		lhs->x << rhs,
		lhs->y << rhs
	};
}

// Performs a component-wise bitwise << against the two vectors and returns the result.
HLML_INLINE int2 int2_cshift_leftv( const int2* lhs, const int2* rhs )
{
	return HLML_CONSTRUCT( int2 )
	{
		lhs->x << rhs->x,
		lhs->y << rhs->y
	};
}

// Performs a component-wise bitwise >> on the vector by the scalar and returns the result.
HLML_INLINE int2 int2_cshift_rights( const int2* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int2 )
	{
		lhs->x >> rhs,
		lhs->y >> rhs
	};
}

// Performs a component-wise bitwise >> against the two vectors and returns the result.
HLML_INLINE int2 int2_cshift_rightv( const int2* lhs, const int2* rhs )
{
	return HLML_CONSTRUCT( int2 )
	{
		lhs->x >> rhs->x,
		lhs->y >> rhs->y
	};
}

// Performs a int2_sign function on each component of the vector.
HLML_INLINE int2 int2_sign( const int2* x )
{
	return HLML_CONSTRUCT( int2 )
	{
		signi( x->x ),
		signi( x->y )
	};
}

// Performs a int2_min function on each component of the vector.
HLML_INLINE int2 int2_min( const int2* x, const int2* y )
{
	return HLML_CONSTRUCT( int2 )
	{
		mini( x->x, y->x ),
		mini( x->y, y->y )
	};
}

// Performs a int2_max function on each component of the vector.
HLML_INLINE int2 int2_max( const int2* x, const int2* y )
{
	return HLML_CONSTRUCT( int2 )
	{
		maxi( x->x, y->x ),
		maxi( x->y, y->y )
	};
}

// Performs a int2_clamp function on each component of the vector.
HLML_INLINE int2 int2_clamp( const int2* x, const int2* low, const int2* high )
{
	return HLML_CONSTRUCT( int2 )
	{
		clampi( x->x, low->x, high->x ),
		clampi( x->y, low->y, high->y )
	};
}

// Performs a int2_saturate function on each component of the vector.
HLML_INLINE int2 int2_saturate( const int2* x )
{
	return HLML_CONSTRUCT( int2 )
	{
		saturatei( x->x ),
		saturatei( x->y )
	};
}

// Returns the magnitude of vector squared.
HLML_INLINE float int2_lengthsq( const int2* vec )
{
	return (float)( ( vec->x * vec->x ) + ( vec->y * vec->y ) );
}

// Returns the magnitude of the vector.
HLML_INLINE float int2_length( const int2* vec )
{
	return sqrtf( int2_lengthsq( vec ) );
}

// Returns the dot product of the two vectors.
HLML_INLINE int32_t int2_dot( const int2* lhs, const int2* rhs )
{
	return ( lhs->x * rhs->x ) + ( lhs->y * rhs->y );
}

// Returns the squared distance between the two vectors.
HLML_INLINE float int2_distancesq( const int2* lhs, const int2* rhs )
{
	int2 delta = int2_csubv( lhs, rhs );
	return int2_lengthsq( &delta );
}

// Returns the distance between the two vectors.
HLML_INLINE float int2_distance( const int2* lhs, const int2* rhs )
{
	int2 delta = int2_csubv( lhs, rhs );
	return int2_length( &delta );
}

// int3
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool int3_equals( const int3* lhs, const int3* rhs )
{
	return
		lhs->x == rhs->x &&
		lhs->y == rhs->y &&
		lhs->z == rhs->z;
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool int3_not_equals( const int3* lhs, const int3* rhs )
{
	return !int3_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two vectors and returns the result.
HLML_INLINE bool3 int3_less_than( const int3* lhs, const int3* rhs )
{
	return HLML_CONSTRUCT( bool3 )
	{
		lhs->x < rhs->x,
		lhs->y < rhs->y,
		lhs->z < rhs->z
	};
}

// Performs a component-wise '<=' check against the two vectors and returns the result.
HLML_INLINE bool3 int3_less_than_equal( const int3* lhs, const int3* rhs )
{
	return HLML_CONSTRUCT( bool3 )
	{
		lhs->x <= rhs->x,
		lhs->y <= rhs->y,
		lhs->z <= rhs->z
	};
}

// Performs a component-wise '>' check against the two vectors and returns the result.
HLML_INLINE bool3 int3_greater_than( const int3* lhs, const int3* rhs )
{
	return HLML_CONSTRUCT( bool3 )
	{
		lhs->x > rhs->x,
		lhs->y > rhs->y,
		lhs->z > rhs->z
	};
}

// Performs a component-wise '>=' check against the two vectors and returns the result.
HLML_INLINE bool3 int3_greater_than_equal( const int3* lhs, const int3* rhs )
{
	return HLML_CONSTRUCT( bool3 )
	{
		lhs->x >= rhs->x,
		lhs->y >= rhs->y,
		lhs->z >= rhs->z
	};
}

// Performs a component-wise + on the vector by the scalar and returns the result.
HLML_INLINE int3 int3_cadds( const int3* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int3 )
	{
		lhs->x + rhs,
		lhs->y + rhs,
		lhs->z + rhs
	};
}

// Performs a component-wise + against the two vectors and returns the result.
HLML_INLINE int3 int3_caddv( const int3* lhs, const int3* rhs )
{
	return HLML_CONSTRUCT( int3 )
	{
		lhs->x + rhs->x,
		lhs->y + rhs->y,
		lhs->z + rhs->z
	};
}

// Performs a component-wise - on the vector by the scalar and returns the result.
HLML_INLINE int3 int3_csubs( const int3* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int3 )
	{
		lhs->x - rhs,
		lhs->y - rhs,
		lhs->z - rhs
	};
}

// Performs a component-wise - against the two vectors and returns the result.
HLML_INLINE int3 int3_csubv( const int3* lhs, const int3* rhs )
{
	return HLML_CONSTRUCT( int3 )
	{
		lhs->x - rhs->x,
		lhs->y - rhs->y,
		lhs->z - rhs->z
	};
}

// Performs a component-wise * on the vector by the scalar and returns the result.
HLML_INLINE int3 int3_cmuls( const int3* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int3 )
	{
		lhs->x * rhs,
		lhs->y * rhs,
		lhs->z * rhs
	};
}

// Performs a component-wise * against the two vectors and returns the result.
HLML_INLINE int3 int3_cmulv( const int3* lhs, const int3* rhs )
{
	return HLML_CONSTRUCT( int3 )
	{
		lhs->x * rhs->x,
		lhs->y * rhs->y,
		lhs->z * rhs->z
	};
}

// Performs a component-wise / on the vector by the scalar and returns the result.
HLML_INLINE int3 int3_cdivs( const int3* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int3 )
	{
		lhs->x / rhs,
		lhs->y / rhs,
		lhs->z / rhs
	};
}

// Performs a component-wise / against the two vectors and returns the result.
HLML_INLINE int3 int3_cdivv( const int3* lhs, const int3* rhs )
{
	return HLML_CONSTRUCT( int3 )
	{
		lhs->x / rhs->x,
		lhs->y / rhs->y,
		lhs->z / rhs->z
	};
}

// Returns a copy of the vector where each component has been bitwise NOT'd.
HLML_INLINE int3 int3_unary( const int3* x )
{
	return HLML_CONSTRUCT( int3 )
	{
		~x->x,
		~x->y,
		~x->z
	};
}

// Performs a component-wise bitwise & on the vector by the scalar and returns the result.
HLML_INLINE int3 int3_cands( const int3* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int3 )
	{
		lhs->x & rhs,
		lhs->y & rhs,
		lhs->z & rhs
	};
}

// Performs a component-wise bitwise & against the two vectors and returns the result.
HLML_INLINE int3 int3_candv( const int3* lhs, const int3* rhs )
{
	return HLML_CONSTRUCT( int3 )
	{
		lhs->x & rhs->x,
		lhs->y & rhs->y,
		lhs->z & rhs->z
	};
}

// Performs a component-wise bitwise | on the vector by the scalar and returns the result.
HLML_INLINE int3 int3_cors( const int3* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int3 )
	{
		lhs->x | rhs,
		lhs->y | rhs,
		lhs->z | rhs
	};
}

// Performs a component-wise bitwise | against the two vectors and returns the result.
HLML_INLINE int3 int3_corv( const int3* lhs, const int3* rhs )
{
	return HLML_CONSTRUCT( int3 )
	{
		lhs->x | rhs->x,
		lhs->y | rhs->y,
		lhs->z | rhs->z
	};
}

// Performs a component-wise bitwise ^ on the vector by the scalar and returns the result.
HLML_INLINE int3 int3_cxors( const int3* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int3 )
	{
		lhs->x ^ rhs,
		lhs->y ^ rhs,
		lhs->z ^ rhs
	};
}

// Performs a component-wise bitwise ^ against the two vectors and returns the result.
HLML_INLINE int3 int3_cxorv( const int3* lhs, const int3* rhs )
{
	return HLML_CONSTRUCT( int3 )
	{
		lhs->x ^ rhs->x,
		lhs->y ^ rhs->y,
		lhs->z ^ rhs->z
	};
}

// Performs a component-wise bitwise << on the vector by the scalar and returns the result.
HLML_INLINE int3 int3_cshift_lefts( const int3* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int3 )
	{
		lhs->x << rhs,
		lhs->y << rhs,
		lhs->z << rhs
	};
}

// Performs a component-wise bitwise << against the two vectors and returns the result.
HLML_INLINE int3 int3_cshift_leftv( const int3* lhs, const int3* rhs )
{
	return HLML_CONSTRUCT( int3 )
	{
		lhs->x << rhs->x,
		lhs->y << rhs->y,
		lhs->z << rhs->z
	};
}

// Performs a component-wise bitwise >> on the vector by the scalar and returns the result.
HLML_INLINE int3 int3_cshift_rights( const int3* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int3 )
	{
		lhs->x >> rhs,
		lhs->y >> rhs,
		lhs->z >> rhs
	};
}

// Performs a component-wise bitwise >> against the two vectors and returns the result.
HLML_INLINE int3 int3_cshift_rightv( const int3* lhs, const int3* rhs )
{
	return HLML_CONSTRUCT( int3 )
	{
		lhs->x >> rhs->x,
		lhs->y >> rhs->y,
		lhs->z >> rhs->z
	};
}

// Performs a int3_sign function on each component of the vector.
HLML_INLINE int3 int3_sign( const int3* x )
{
	return HLML_CONSTRUCT( int3 )
	{
		signi( x->x ),
		signi( x->y ),
		signi( x->z )
	};
}

// Performs a int3_min function on each component of the vector.
HLML_INLINE int3 int3_min( const int3* x, const int3* y )
{
	return HLML_CONSTRUCT( int3 )
	{
		mini( x->x, y->x ),
		mini( x->y, y->y ),
		mini( x->z, y->z )
	};
}

// Performs a int3_max function on each component of the vector.
HLML_INLINE int3 int3_max( const int3* x, const int3* y )
{
	return HLML_CONSTRUCT( int3 )
	{
		maxi( x->x, y->x ),
		maxi( x->y, y->y ),
		maxi( x->z, y->z )
	};
}

// Performs a int3_clamp function on each component of the vector.
HLML_INLINE int3 int3_clamp( const int3* x, const int3* low, const int3* high )
{
	return HLML_CONSTRUCT( int3 )
	{
		clampi( x->x, low->x, high->x ),
		clampi( x->y, low->y, high->y ),
		clampi( x->z, low->z, high->z )
	};
}

// Performs a int3_saturate function on each component of the vector.
HLML_INLINE int3 int3_saturate( const int3* x )
{
	return HLML_CONSTRUCT( int3 )
	{
		saturatei( x->x ),
		saturatei( x->y ),
		saturatei( x->z )
	};
}

// Returns the magnitude of vector squared.
HLML_INLINE float int3_lengthsq( const int3* vec )
{
	return (float)( ( vec->x * vec->x ) + ( vec->y * vec->y ) + ( vec->z * vec->z ) );
}

// Returns the magnitude of the vector.
HLML_INLINE float int3_length( const int3* vec )
{
	return sqrtf( int3_lengthsq( vec ) );
}

// Returns the dot product of the two vectors.
HLML_INLINE int32_t int3_dot( const int3* lhs, const int3* rhs )
{
	return ( lhs->x * rhs->x ) + ( lhs->y * rhs->y ) + ( lhs->z * rhs->z );
}

// Returns the squared distance between the two vectors.
HLML_INLINE float int3_distancesq( const int3* lhs, const int3* rhs )
{
	int3 delta = int3_csubv( lhs, rhs );
	return int3_lengthsq( &delta );
}

// Returns the distance between the two vectors.
HLML_INLINE float int3_distance( const int3* lhs, const int3* rhs )
{
	int3 delta = int3_csubv( lhs, rhs );
	return int3_length( &delta );
}

// int4
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool int4_equals( const int4* lhs, const int4* rhs )
{
	return
		lhs->x == rhs->x &&
		lhs->y == rhs->y &&
		lhs->z == rhs->z &&
		lhs->w == rhs->w;
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool int4_not_equals( const int4* lhs, const int4* rhs )
{
	return !int4_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two vectors and returns the result.
HLML_INLINE bool4 int4_less_than( const int4* lhs, const int4* rhs )
{
	return HLML_CONSTRUCT( bool4 )
	{
		lhs->x < rhs->x,
		lhs->y < rhs->y,
		lhs->z < rhs->z,
		lhs->w < rhs->w
	};
}

// Performs a component-wise '<=' check against the two vectors and returns the result.
HLML_INLINE bool4 int4_less_than_equal( const int4* lhs, const int4* rhs )
{
	return HLML_CONSTRUCT( bool4 )
	{
		lhs->x <= rhs->x,
		lhs->y <= rhs->y,
		lhs->z <= rhs->z,
		lhs->w <= rhs->w
	};
}

// Performs a component-wise '>' check against the two vectors and returns the result.
HLML_INLINE bool4 int4_greater_than( const int4* lhs, const int4* rhs )
{
	return HLML_CONSTRUCT( bool4 )
	{
		lhs->x > rhs->x,
		lhs->y > rhs->y,
		lhs->z > rhs->z,
		lhs->w > rhs->w
	};
}

// Performs a component-wise '>=' check against the two vectors and returns the result.
HLML_INLINE bool4 int4_greater_than_equal( const int4* lhs, const int4* rhs )
{
	return HLML_CONSTRUCT( bool4 )
	{
		lhs->x >= rhs->x,
		lhs->y >= rhs->y,
		lhs->z >= rhs->z,
		lhs->w >= rhs->w
	};
}

// Performs a component-wise + on the vector by the scalar and returns the result.
HLML_INLINE int4 int4_cadds( const int4* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int4 )
	{
		lhs->x + rhs,
		lhs->y + rhs,
		lhs->z + rhs,
		lhs->w + rhs
	};
}

// Performs a component-wise + against the two vectors and returns the result.
HLML_INLINE int4 int4_caddv( const int4* lhs, const int4* rhs )
{
	return HLML_CONSTRUCT( int4 )
	{
		lhs->x + rhs->x,
		lhs->y + rhs->y,
		lhs->z + rhs->z,
		lhs->w + rhs->w
	};
}

// Performs a component-wise - on the vector by the scalar and returns the result.
HLML_INLINE int4 int4_csubs( const int4* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int4 )
	{
		lhs->x - rhs,
		lhs->y - rhs,
		lhs->z - rhs,
		lhs->w - rhs
	};
}

// Performs a component-wise - against the two vectors and returns the result.
HLML_INLINE int4 int4_csubv( const int4* lhs, const int4* rhs )
{
	return HLML_CONSTRUCT( int4 )
	{
		lhs->x - rhs->x,
		lhs->y - rhs->y,
		lhs->z - rhs->z,
		lhs->w - rhs->w
	};
}

// Performs a component-wise * on the vector by the scalar and returns the result.
HLML_INLINE int4 int4_cmuls( const int4* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int4 )
	{
		lhs->x * rhs,
		lhs->y * rhs,
		lhs->z * rhs,
		lhs->w * rhs
	};
}

// Performs a component-wise * against the two vectors and returns the result.
HLML_INLINE int4 int4_cmulv( const int4* lhs, const int4* rhs )
{
	return HLML_CONSTRUCT( int4 )
	{
		lhs->x * rhs->x,
		lhs->y * rhs->y,
		lhs->z * rhs->z,
		lhs->w * rhs->w
	};
}

// Performs a component-wise / on the vector by the scalar and returns the result.
HLML_INLINE int4 int4_cdivs( const int4* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int4 )
	{
		lhs->x / rhs,
		lhs->y / rhs,
		lhs->z / rhs,
		lhs->w / rhs
	};
}

// Performs a component-wise / against the two vectors and returns the result.
HLML_INLINE int4 int4_cdivv( const int4* lhs, const int4* rhs )
{
	return HLML_CONSTRUCT( int4 )
	{
		lhs->x / rhs->x,
		lhs->y / rhs->y,
		lhs->z / rhs->z,
		lhs->w / rhs->w
	};
}

// Returns a copy of the vector where each component has been bitwise NOT'd.
HLML_INLINE int4 int4_unary( const int4* x )
{
	return HLML_CONSTRUCT( int4 )
	{
		~x->x,
		~x->y,
		~x->z,
		~x->w
	};
}

// Performs a component-wise bitwise & on the vector by the scalar and returns the result.
HLML_INLINE int4 int4_cands( const int4* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int4 )
	{
		lhs->x & rhs,
		lhs->y & rhs,
		lhs->z & rhs,
		lhs->w & rhs
	};
}

// Performs a component-wise bitwise & against the two vectors and returns the result.
HLML_INLINE int4 int4_candv( const int4* lhs, const int4* rhs )
{
	return HLML_CONSTRUCT( int4 )
	{
		lhs->x & rhs->x,
		lhs->y & rhs->y,
		lhs->z & rhs->z,
		lhs->w & rhs->w
	};
}

// Performs a component-wise bitwise | on the vector by the scalar and returns the result.
HLML_INLINE int4 int4_cors( const int4* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int4 )
	{
		lhs->x | rhs,
		lhs->y | rhs,
		lhs->z | rhs,
		lhs->w | rhs
	};
}

// Performs a component-wise bitwise | against the two vectors and returns the result.
HLML_INLINE int4 int4_corv( const int4* lhs, const int4* rhs )
{
	return HLML_CONSTRUCT( int4 )
	{
		lhs->x | rhs->x,
		lhs->y | rhs->y,
		lhs->z | rhs->z,
		lhs->w | rhs->w
	};
}

// Performs a component-wise bitwise ^ on the vector by the scalar and returns the result.
HLML_INLINE int4 int4_cxors( const int4* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int4 )
	{
		lhs->x ^ rhs,
		lhs->y ^ rhs,
		lhs->z ^ rhs,
		lhs->w ^ rhs
	};
}

// Performs a component-wise bitwise ^ against the two vectors and returns the result.
HLML_INLINE int4 int4_cxorv( const int4* lhs, const int4* rhs )
{
	return HLML_CONSTRUCT( int4 )
	{
		lhs->x ^ rhs->x,
		lhs->y ^ rhs->y,
		lhs->z ^ rhs->z,
		lhs->w ^ rhs->w
	};
}

// Performs a component-wise bitwise << on the vector by the scalar and returns the result.
HLML_INLINE int4 int4_cshift_lefts( const int4* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int4 )
	{
		lhs->x << rhs,
		lhs->y << rhs,
		lhs->z << rhs,
		lhs->w << rhs
	};
}

// Performs a component-wise bitwise << against the two vectors and returns the result.
HLML_INLINE int4 int4_cshift_leftv( const int4* lhs, const int4* rhs )
{
	return HLML_CONSTRUCT( int4 )
	{
		lhs->x << rhs->x,
		lhs->y << rhs->y,
		lhs->z << rhs->z,
		lhs->w << rhs->w
	};
}

// Performs a component-wise bitwise >> on the vector by the scalar and returns the result.
HLML_INLINE int4 int4_cshift_rights( const int4* lhs, const int32_t rhs )
{
	return HLML_CONSTRUCT( int4 )
	{
		lhs->x >> rhs,
		lhs->y >> rhs,
		lhs->z >> rhs,
		lhs->w >> rhs
	};
}

// Performs a component-wise bitwise >> against the two vectors and returns the result.
HLML_INLINE int4 int4_cshift_rightv( const int4* lhs, const int4* rhs )
{
	return HLML_CONSTRUCT( int4 )
	{
		lhs->x >> rhs->x,
		lhs->y >> rhs->y,
		lhs->z >> rhs->z,
		lhs->w >> rhs->w
	};
}

// Performs a int4_sign function on each component of the vector.
HLML_INLINE int4 int4_sign( const int4* x )
{
	return HLML_CONSTRUCT( int4 )
	{
		signi( x->x ),
		signi( x->y ),
		signi( x->z ),
		signi( x->w )
	};
}

// Performs a int4_min function on each component of the vector.
HLML_INLINE int4 int4_min( const int4* x, const int4* y )
{
	return HLML_CONSTRUCT( int4 )
	{
		mini( x->x, y->x ),
		mini( x->y, y->y ),
		mini( x->z, y->z ),
		mini( x->w, y->w )
	};
}

// Performs a int4_max function on each component of the vector.
HLML_INLINE int4 int4_max( const int4* x, const int4* y )
{
	return HLML_CONSTRUCT( int4 )
	{
		maxi( x->x, y->x ),
		maxi( x->y, y->y ),
		maxi( x->z, y->z ),
		maxi( x->w, y->w )
	};
}

// Performs a int4_clamp function on each component of the vector.
HLML_INLINE int4 int4_clamp( const int4* x, const int4* low, const int4* high )
{
	return HLML_CONSTRUCT( int4 )
	{
		clampi( x->x, low->x, high->x ),
		clampi( x->y, low->y, high->y ),
		clampi( x->z, low->z, high->z ),
		clampi( x->w, low->w, high->w )
	};
}

// Performs a int4_saturate function on each component of the vector.
HLML_INLINE int4 int4_saturate( const int4* x )
{
	return HLML_CONSTRUCT( int4 )
	{
		saturatei( x->x ),
		saturatei( x->y ),
		saturatei( x->z ),
		saturatei( x->w )
	};
}

// Returns the magnitude of vector squared.
HLML_INLINE float int4_lengthsq( const int4* vec )
{
	return (float)( ( vec->x * vec->x ) + ( vec->y * vec->y ) + ( vec->z * vec->z ) + ( vec->w * vec->w ) );
}

// Returns the magnitude of the vector.
HLML_INLINE float int4_length( const int4* vec )
{
	return sqrtf( int4_lengthsq( vec ) );
}

// Returns the dot product of the two vectors.
HLML_INLINE int32_t int4_dot( const int4* lhs, const int4* rhs )
{
	return ( lhs->x * rhs->x ) + ( lhs->y * rhs->y ) + ( lhs->z * rhs->z ) + ( lhs->w * rhs->w );
}

// uint2
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool uint2_equals( const uint2* lhs, const uint2* rhs )
{
	return
		lhs->x == rhs->x &&
		lhs->y == rhs->y;
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool uint2_not_equals( const uint2* lhs, const uint2* rhs )
{
	return !uint2_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two vectors and returns the result.
HLML_INLINE bool2 uint2_less_than( const uint2* lhs, const uint2* rhs )
{
	return HLML_CONSTRUCT( bool2 )
	{
		lhs->x < rhs->x,
		lhs->y < rhs->y
	};
}

// Performs a component-wise '<=' check against the two vectors and returns the result.
HLML_INLINE bool2 uint2_less_than_equal( const uint2* lhs, const uint2* rhs )
{
	return HLML_CONSTRUCT( bool2 )
	{
		lhs->x <= rhs->x,
		lhs->y <= rhs->y
	};
}

// Performs a component-wise '>' check against the two vectors and returns the result.
HLML_INLINE bool2 uint2_greater_than( const uint2* lhs, const uint2* rhs )
{
	return HLML_CONSTRUCT( bool2 )
	{
		lhs->x > rhs->x,
		lhs->y > rhs->y
	};
}

// Performs a component-wise '>=' check against the two vectors and returns the result.
HLML_INLINE bool2 uint2_greater_than_equal( const uint2* lhs, const uint2* rhs )
{
	return HLML_CONSTRUCT( bool2 )
	{
		lhs->x >= rhs->x,
		lhs->y >= rhs->y
	};
}

// Performs a component-wise + on the vector by the scalar and returns the result.
HLML_INLINE uint2 uint2_cadds( const uint2* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint2 )
	{
		lhs->x + rhs,
		lhs->y + rhs
	};
}

// Performs a component-wise + against the two vectors and returns the result.
HLML_INLINE uint2 uint2_caddv( const uint2* lhs, const uint2* rhs )
{
	return HLML_CONSTRUCT( uint2 )
	{
		lhs->x + rhs->x,
		lhs->y + rhs->y
	};
}

// Performs a component-wise - on the vector by the scalar and returns the result.
HLML_INLINE uint2 uint2_csubs( const uint2* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint2 )
	{
		lhs->x - rhs,
		lhs->y - rhs
	};
}

// Performs a component-wise - against the two vectors and returns the result.
HLML_INLINE uint2 uint2_csubv( const uint2* lhs, const uint2* rhs )
{
	return HLML_CONSTRUCT( uint2 )
	{
		lhs->x - rhs->x,
		lhs->y - rhs->y
	};
}

// Performs a component-wise * on the vector by the scalar and returns the result.
HLML_INLINE uint2 uint2_cmuls( const uint2* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint2 )
	{
		lhs->x * rhs,
		lhs->y * rhs
	};
}

// Performs a component-wise * against the two vectors and returns the result.
HLML_INLINE uint2 uint2_cmulv( const uint2* lhs, const uint2* rhs )
{
	return HLML_CONSTRUCT( uint2 )
	{
		lhs->x * rhs->x,
		lhs->y * rhs->y
	};
}

// Performs a component-wise / on the vector by the scalar and returns the result.
HLML_INLINE uint2 uint2_cdivs( const uint2* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint2 )
	{
		lhs->x / rhs,
		lhs->y / rhs
	};
}

// Performs a component-wise / against the two vectors and returns the result.
HLML_INLINE uint2 uint2_cdivv( const uint2* lhs, const uint2* rhs )
{
	return HLML_CONSTRUCT( uint2 )
	{
		lhs->x / rhs->x,
		lhs->y / rhs->y
	};
}

// Returns a copy of the vector where each component has been bitwise NOT'd.
HLML_INLINE uint2 uint2_unary( const uint2* x )
{
	return HLML_CONSTRUCT( uint2 )
	{
		~x->x,
		~x->y
	};
}

// Performs a component-wise bitwise & on the vector by the scalar and returns the result.
HLML_INLINE uint2 uint2_cands( const uint2* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint2 )
	{
		lhs->x & rhs,
		lhs->y & rhs
	};
}

// Performs a component-wise bitwise & against the two vectors and returns the result.
HLML_INLINE uint2 uint2_candv( const uint2* lhs, const uint2* rhs )
{
	return HLML_CONSTRUCT( uint2 )
	{
		lhs->x & rhs->x,
		lhs->y & rhs->y
	};
}

// Performs a component-wise bitwise | on the vector by the scalar and returns the result.
HLML_INLINE uint2 uint2_cors( const uint2* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint2 )
	{
		lhs->x | rhs,
		lhs->y | rhs
	};
}

// Performs a component-wise bitwise | against the two vectors and returns the result.
HLML_INLINE uint2 uint2_corv( const uint2* lhs, const uint2* rhs )
{
	return HLML_CONSTRUCT( uint2 )
	{
		lhs->x | rhs->x,
		lhs->y | rhs->y
	};
}

// Performs a component-wise bitwise ^ on the vector by the scalar and returns the result.
HLML_INLINE uint2 uint2_cxors( const uint2* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint2 )
	{
		lhs->x ^ rhs,
		lhs->y ^ rhs
	};
}

// Performs a component-wise bitwise ^ against the two vectors and returns the result.
HLML_INLINE uint2 uint2_cxorv( const uint2* lhs, const uint2* rhs )
{
	return HLML_CONSTRUCT( uint2 )
	{
		lhs->x ^ rhs->x,
		lhs->y ^ rhs->y
	};
}

// Performs a component-wise bitwise << on the vector by the scalar and returns the result.
HLML_INLINE uint2 uint2_cshift_lefts( const uint2* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint2 )
	{
		lhs->x << rhs,
		lhs->y << rhs
	};
}

// Performs a component-wise bitwise << against the two vectors and returns the result.
HLML_INLINE uint2 uint2_cshift_leftv( const uint2* lhs, const uint2* rhs )
{
	return HLML_CONSTRUCT( uint2 )
	{
		lhs->x << rhs->x,
		lhs->y << rhs->y
	};
}

// Performs a component-wise bitwise >> on the vector by the scalar and returns the result.
HLML_INLINE uint2 uint2_cshift_rights( const uint2* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint2 )
	{
		lhs->x >> rhs,
		lhs->y >> rhs
	};
}

// Performs a component-wise bitwise >> against the two vectors and returns the result.
HLML_INLINE uint2 uint2_cshift_rightv( const uint2* lhs, const uint2* rhs )
{
	return HLML_CONSTRUCT( uint2 )
	{
		lhs->x >> rhs->x,
		lhs->y >> rhs->y
	};
}

// Performs a uint2_min function on each component of the vector.
HLML_INLINE uint2 uint2_min( const uint2* x, const uint2* y )
{
	return HLML_CONSTRUCT( uint2 )
	{
		minu( x->x, y->x ),
		minu( x->y, y->y )
	};
}

// Performs a uint2_max function on each component of the vector.
HLML_INLINE uint2 uint2_max( const uint2* x, const uint2* y )
{
	return HLML_CONSTRUCT( uint2 )
	{
		maxu( x->x, y->x ),
		maxu( x->y, y->y )
	};
}

// Performs a uint2_clamp function on each component of the vector.
HLML_INLINE uint2 uint2_clamp( const uint2* x, const uint2* low, const uint2* high )
{
	return HLML_CONSTRUCT( uint2 )
	{
		clampu( x->x, low->x, high->x ),
		clampu( x->y, low->y, high->y )
	};
}

// Performs a uint2_saturate function on each component of the vector.
HLML_INLINE uint2 uint2_saturate( const uint2* x )
{
	return HLML_CONSTRUCT( uint2 )
	{
		saturateu( x->x ),
		saturateu( x->y )
	};
}

// Returns the magnitude of vector squared.
HLML_INLINE float uint2_lengthsq( const uint2* vec )
{
	return (float)( ( vec->x * vec->x ) + ( vec->y * vec->y ) );
}

// Returns the magnitude of the vector.
HLML_INLINE float uint2_length( const uint2* vec )
{
	return sqrtf( uint2_lengthsq( vec ) );
}

// Returns the dot product of the two vectors.
HLML_INLINE uint32_t uint2_dot( const uint2* lhs, const uint2* rhs )
{
	return ( lhs->x * rhs->x ) + ( lhs->y * rhs->y );
}

// Returns the squared distance between the two vectors.
HLML_INLINE float uint2_distancesq( const uint2* lhs, const uint2* rhs )
{
	uint2 delta = uint2_csubv( lhs, rhs );
	return uint2_lengthsq( &delta );
}

// Returns the distance between the two vectors.
HLML_INLINE float uint2_distance( const uint2* lhs, const uint2* rhs )
{
	uint2 delta = uint2_csubv( lhs, rhs );
	return uint2_length( &delta );
}

// uint3
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool uint3_equals( const uint3* lhs, const uint3* rhs )
{
	return
		lhs->x == rhs->x &&
		lhs->y == rhs->y &&
		lhs->z == rhs->z;
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool uint3_not_equals( const uint3* lhs, const uint3* rhs )
{
	return !uint3_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two vectors and returns the result.
HLML_INLINE bool3 uint3_less_than( const uint3* lhs, const uint3* rhs )
{
	return HLML_CONSTRUCT( bool3 )
	{
		lhs->x < rhs->x,
		lhs->y < rhs->y,
		lhs->z < rhs->z
	};
}

// Performs a component-wise '<=' check against the two vectors and returns the result.
HLML_INLINE bool3 uint3_less_than_equal( const uint3* lhs, const uint3* rhs )
{
	return HLML_CONSTRUCT( bool3 )
	{
		lhs->x <= rhs->x,
		lhs->y <= rhs->y,
		lhs->z <= rhs->z
	};
}

// Performs a component-wise '>' check against the two vectors and returns the result.
HLML_INLINE bool3 uint3_greater_than( const uint3* lhs, const uint3* rhs )
{
	return HLML_CONSTRUCT( bool3 )
	{
		lhs->x > rhs->x,
		lhs->y > rhs->y,
		lhs->z > rhs->z
	};
}

// Performs a component-wise '>=' check against the two vectors and returns the result.
HLML_INLINE bool3 uint3_greater_than_equal( const uint3* lhs, const uint3* rhs )
{
	return HLML_CONSTRUCT( bool3 )
	{
		lhs->x >= rhs->x,
		lhs->y >= rhs->y,
		lhs->z >= rhs->z
	};
}

// Performs a component-wise + on the vector by the scalar and returns the result.
HLML_INLINE uint3 uint3_cadds( const uint3* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint3 )
	{
		lhs->x + rhs,
		lhs->y + rhs,
		lhs->z + rhs
	};
}

// Performs a component-wise + against the two vectors and returns the result.
HLML_INLINE uint3 uint3_caddv( const uint3* lhs, const uint3* rhs )
{
	return HLML_CONSTRUCT( uint3 )
	{
		lhs->x + rhs->x,
		lhs->y + rhs->y,
		lhs->z + rhs->z
	};
}

// Performs a component-wise - on the vector by the scalar and returns the result.
HLML_INLINE uint3 uint3_csubs( const uint3* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint3 )
	{
		lhs->x - rhs,
		lhs->y - rhs,
		lhs->z - rhs
	};
}

// Performs a component-wise - against the two vectors and returns the result.
HLML_INLINE uint3 uint3_csubv( const uint3* lhs, const uint3* rhs )
{
	return HLML_CONSTRUCT( uint3 )
	{
		lhs->x - rhs->x,
		lhs->y - rhs->y,
		lhs->z - rhs->z
	};
}

// Performs a component-wise * on the vector by the scalar and returns the result.
HLML_INLINE uint3 uint3_cmuls( const uint3* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint3 )
	{
		lhs->x * rhs,
		lhs->y * rhs,
		lhs->z * rhs
	};
}

// Performs a component-wise * against the two vectors and returns the result.
HLML_INLINE uint3 uint3_cmulv( const uint3* lhs, const uint3* rhs )
{
	return HLML_CONSTRUCT( uint3 )
	{
		lhs->x * rhs->x,
		lhs->y * rhs->y,
		lhs->z * rhs->z
	};
}

// Performs a component-wise / on the vector by the scalar and returns the result.
HLML_INLINE uint3 uint3_cdivs( const uint3* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint3 )
	{
		lhs->x / rhs,
		lhs->y / rhs,
		lhs->z / rhs
	};
}

// Performs a component-wise / against the two vectors and returns the result.
HLML_INLINE uint3 uint3_cdivv( const uint3* lhs, const uint3* rhs )
{
	return HLML_CONSTRUCT( uint3 )
	{
		lhs->x / rhs->x,
		lhs->y / rhs->y,
		lhs->z / rhs->z
	};
}

// Returns a copy of the vector where each component has been bitwise NOT'd.
HLML_INLINE uint3 uint3_unary( const uint3* x )
{
	return HLML_CONSTRUCT( uint3 )
	{
		~x->x,
		~x->y,
		~x->z
	};
}

// Performs a component-wise bitwise & on the vector by the scalar and returns the result.
HLML_INLINE uint3 uint3_cands( const uint3* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint3 )
	{
		lhs->x & rhs,
		lhs->y & rhs,
		lhs->z & rhs
	};
}

// Performs a component-wise bitwise & against the two vectors and returns the result.
HLML_INLINE uint3 uint3_candv( const uint3* lhs, const uint3* rhs )
{
	return HLML_CONSTRUCT( uint3 )
	{
		lhs->x & rhs->x,
		lhs->y & rhs->y,
		lhs->z & rhs->z
	};
}

// Performs a component-wise bitwise | on the vector by the scalar and returns the result.
HLML_INLINE uint3 uint3_cors( const uint3* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint3 )
	{
		lhs->x | rhs,
		lhs->y | rhs,
		lhs->z | rhs
	};
}

// Performs a component-wise bitwise | against the two vectors and returns the result.
HLML_INLINE uint3 uint3_corv( const uint3* lhs, const uint3* rhs )
{
	return HLML_CONSTRUCT( uint3 )
	{
		lhs->x | rhs->x,
		lhs->y | rhs->y,
		lhs->z | rhs->z
	};
}

// Performs a component-wise bitwise ^ on the vector by the scalar and returns the result.
HLML_INLINE uint3 uint3_cxors( const uint3* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint3 )
	{
		lhs->x ^ rhs,
		lhs->y ^ rhs,
		lhs->z ^ rhs
	};
}

// Performs a component-wise bitwise ^ against the two vectors and returns the result.
HLML_INLINE uint3 uint3_cxorv( const uint3* lhs, const uint3* rhs )
{
	return HLML_CONSTRUCT( uint3 )
	{
		lhs->x ^ rhs->x,
		lhs->y ^ rhs->y,
		lhs->z ^ rhs->z
	};
}

// Performs a component-wise bitwise << on the vector by the scalar and returns the result.
HLML_INLINE uint3 uint3_cshift_lefts( const uint3* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint3 )
	{
		lhs->x << rhs,
		lhs->y << rhs,
		lhs->z << rhs
	};
}

// Performs a component-wise bitwise << against the two vectors and returns the result.
HLML_INLINE uint3 uint3_cshift_leftv( const uint3* lhs, const uint3* rhs )
{
	return HLML_CONSTRUCT( uint3 )
	{
		lhs->x << rhs->x,
		lhs->y << rhs->y,
		lhs->z << rhs->z
	};
}

// Performs a component-wise bitwise >> on the vector by the scalar and returns the result.
HLML_INLINE uint3 uint3_cshift_rights( const uint3* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint3 )
	{
		lhs->x >> rhs,
		lhs->y >> rhs,
		lhs->z >> rhs
	};
}

// Performs a component-wise bitwise >> against the two vectors and returns the result.
HLML_INLINE uint3 uint3_cshift_rightv( const uint3* lhs, const uint3* rhs )
{
	return HLML_CONSTRUCT( uint3 )
	{
		lhs->x >> rhs->x,
		lhs->y >> rhs->y,
		lhs->z >> rhs->z
	};
}

// Performs a uint3_min function on each component of the vector.
HLML_INLINE uint3 uint3_min( const uint3* x, const uint3* y )
{
	return HLML_CONSTRUCT( uint3 )
	{
		minu( x->x, y->x ),
		minu( x->y, y->y ),
		minu( x->z, y->z )
	};
}

// Performs a uint3_max function on each component of the vector.
HLML_INLINE uint3 uint3_max( const uint3* x, const uint3* y )
{
	return HLML_CONSTRUCT( uint3 )
	{
		maxu( x->x, y->x ),
		maxu( x->y, y->y ),
		maxu( x->z, y->z )
	};
}

// Performs a uint3_clamp function on each component of the vector.
HLML_INLINE uint3 uint3_clamp( const uint3* x, const uint3* low, const uint3* high )
{
	return HLML_CONSTRUCT( uint3 )
	{
		clampu( x->x, low->x, high->x ),
		clampu( x->y, low->y, high->y ),
		clampu( x->z, low->z, high->z )
	};
}

// Performs a uint3_saturate function on each component of the vector.
HLML_INLINE uint3 uint3_saturate( const uint3* x )
{
	return HLML_CONSTRUCT( uint3 )
	{
		saturateu( x->x ),
		saturateu( x->y ),
		saturateu( x->z )
	};
}

// Returns the magnitude of vector squared.
HLML_INLINE float uint3_lengthsq( const uint3* vec )
{
	return (float)( ( vec->x * vec->x ) + ( vec->y * vec->y ) + ( vec->z * vec->z ) );
}

// Returns the magnitude of the vector.
HLML_INLINE float uint3_length( const uint3* vec )
{
	return sqrtf( uint3_lengthsq( vec ) );
}

// Returns the dot product of the two vectors.
HLML_INLINE uint32_t uint3_dot( const uint3* lhs, const uint3* rhs )
{
	return ( lhs->x * rhs->x ) + ( lhs->y * rhs->y ) + ( lhs->z * rhs->z );
}

// Returns the squared distance between the two vectors.
HLML_INLINE float uint3_distancesq( const uint3* lhs, const uint3* rhs )
{
	uint3 delta = uint3_csubv( lhs, rhs );
	return uint3_lengthsq( &delta );
}

// Returns the distance between the two vectors.
HLML_INLINE float uint3_distance( const uint3* lhs, const uint3* rhs )
{
	uint3 delta = uint3_csubv( lhs, rhs );
	return uint3_length( &delta );
}

// uint4
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool uint4_equals( const uint4* lhs, const uint4* rhs )
{
	return
		lhs->x == rhs->x &&
		lhs->y == rhs->y &&
		lhs->z == rhs->z &&
		lhs->w == rhs->w;
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool uint4_not_equals( const uint4* lhs, const uint4* rhs )
{
	return !uint4_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two vectors and returns the result.
HLML_INLINE bool4 uint4_less_than( const uint4* lhs, const uint4* rhs )
{
	return HLML_CONSTRUCT( bool4 )
	{
		lhs->x < rhs->x,
		lhs->y < rhs->y,
		lhs->z < rhs->z,
		lhs->w < rhs->w
	};
}

// Performs a component-wise '<=' check against the two vectors and returns the result.
HLML_INLINE bool4 uint4_less_than_equal( const uint4* lhs, const uint4* rhs )
{
	return HLML_CONSTRUCT( bool4 )
	{
		lhs->x <= rhs->x,
		lhs->y <= rhs->y,
		lhs->z <= rhs->z,
		lhs->w <= rhs->w
	};
}

// Performs a component-wise '>' check against the two vectors and returns the result.
HLML_INLINE bool4 uint4_greater_than( const uint4* lhs, const uint4* rhs )
{
	return HLML_CONSTRUCT( bool4 )
	{
		lhs->x > rhs->x,
		lhs->y > rhs->y,
		lhs->z > rhs->z,
		lhs->w > rhs->w
	};
}

// Performs a component-wise '>=' check against the two vectors and returns the result.
HLML_INLINE bool4 uint4_greater_than_equal( const uint4* lhs, const uint4* rhs )
{
	return HLML_CONSTRUCT( bool4 )
	{
		lhs->x >= rhs->x,
		lhs->y >= rhs->y,
		lhs->z >= rhs->z,
		lhs->w >= rhs->w
	};
}

// Performs a component-wise + on the vector by the scalar and returns the result.
HLML_INLINE uint4 uint4_cadds( const uint4* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint4 )
	{
		lhs->x + rhs,
		lhs->y + rhs,
		lhs->z + rhs,
		lhs->w + rhs
	};
}

// Performs a component-wise + against the two vectors and returns the result.
HLML_INLINE uint4 uint4_caddv( const uint4* lhs, const uint4* rhs )
{
	return HLML_CONSTRUCT( uint4 )
	{
		lhs->x + rhs->x,
		lhs->y + rhs->y,
		lhs->z + rhs->z,
		lhs->w + rhs->w
	};
}

// Performs a component-wise - on the vector by the scalar and returns the result.
HLML_INLINE uint4 uint4_csubs( const uint4* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint4 )
	{
		lhs->x - rhs,
		lhs->y - rhs,
		lhs->z - rhs,
		lhs->w - rhs
	};
}

// Performs a component-wise - against the two vectors and returns the result.
HLML_INLINE uint4 uint4_csubv( const uint4* lhs, const uint4* rhs )
{
	return HLML_CONSTRUCT( uint4 )
	{
		lhs->x - rhs->x,
		lhs->y - rhs->y,
		lhs->z - rhs->z,
		lhs->w - rhs->w
	};
}

// Performs a component-wise * on the vector by the scalar and returns the result.
HLML_INLINE uint4 uint4_cmuls( const uint4* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint4 )
	{
		lhs->x * rhs,
		lhs->y * rhs,
		lhs->z * rhs,
		lhs->w * rhs
	};
}

// Performs a component-wise * against the two vectors and returns the result.
HLML_INLINE uint4 uint4_cmulv( const uint4* lhs, const uint4* rhs )
{
	return HLML_CONSTRUCT( uint4 )
	{
		lhs->x * rhs->x,
		lhs->y * rhs->y,
		lhs->z * rhs->z,
		lhs->w * rhs->w
	};
}

// Performs a component-wise / on the vector by the scalar and returns the result.
HLML_INLINE uint4 uint4_cdivs( const uint4* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint4 )
	{
		lhs->x / rhs,
		lhs->y / rhs,
		lhs->z / rhs,
		lhs->w / rhs
	};
}

// Performs a component-wise / against the two vectors and returns the result.
HLML_INLINE uint4 uint4_cdivv( const uint4* lhs, const uint4* rhs )
{
	return HLML_CONSTRUCT( uint4 )
	{
		lhs->x / rhs->x,
		lhs->y / rhs->y,
		lhs->z / rhs->z,
		lhs->w / rhs->w
	};
}

// Returns a copy of the vector where each component has been bitwise NOT'd.
HLML_INLINE uint4 uint4_unary( const uint4* x )
{
	return HLML_CONSTRUCT( uint4 )
	{
		~x->x,
		~x->y,
		~x->z,
		~x->w
	};
}

// Performs a component-wise bitwise & on the vector by the scalar and returns the result.
HLML_INLINE uint4 uint4_cands( const uint4* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint4 )
	{
		lhs->x & rhs,
		lhs->y & rhs,
		lhs->z & rhs,
		lhs->w & rhs
	};
}

// Performs a component-wise bitwise & against the two vectors and returns the result.
HLML_INLINE uint4 uint4_candv( const uint4* lhs, const uint4* rhs )
{
	return HLML_CONSTRUCT( uint4 )
	{
		lhs->x & rhs->x,
		lhs->y & rhs->y,
		lhs->z & rhs->z,
		lhs->w & rhs->w
	};
}

// Performs a component-wise bitwise | on the vector by the scalar and returns the result.
HLML_INLINE uint4 uint4_cors( const uint4* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint4 )
	{
		lhs->x | rhs,
		lhs->y | rhs,
		lhs->z | rhs,
		lhs->w | rhs
	};
}

// Performs a component-wise bitwise | against the two vectors and returns the result.
HLML_INLINE uint4 uint4_corv( const uint4* lhs, const uint4* rhs )
{
	return HLML_CONSTRUCT( uint4 )
	{
		lhs->x | rhs->x,
		lhs->y | rhs->y,
		lhs->z | rhs->z,
		lhs->w | rhs->w
	};
}

// Performs a component-wise bitwise ^ on the vector by the scalar and returns the result.
HLML_INLINE uint4 uint4_cxors( const uint4* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint4 )
	{
		lhs->x ^ rhs,
		lhs->y ^ rhs,
		lhs->z ^ rhs,
		lhs->w ^ rhs
	};
}

// Performs a component-wise bitwise ^ against the two vectors and returns the result.
HLML_INLINE uint4 uint4_cxorv( const uint4* lhs, const uint4* rhs )
{
	return HLML_CONSTRUCT( uint4 )
	{
		lhs->x ^ rhs->x,
		lhs->y ^ rhs->y,
		lhs->z ^ rhs->z,
		lhs->w ^ rhs->w
	};
}

// Performs a component-wise bitwise << on the vector by the scalar and returns the result.
HLML_INLINE uint4 uint4_cshift_lefts( const uint4* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint4 )
	{
		lhs->x << rhs,
		lhs->y << rhs,
		lhs->z << rhs,
		lhs->w << rhs
	};
}

// Performs a component-wise bitwise << against the two vectors and returns the result.
HLML_INLINE uint4 uint4_cshift_leftv( const uint4* lhs, const uint4* rhs )
{
	return HLML_CONSTRUCT( uint4 )
	{
		lhs->x << rhs->x,
		lhs->y << rhs->y,
		lhs->z << rhs->z,
		lhs->w << rhs->w
	};
}

// Performs a component-wise bitwise >> on the vector by the scalar and returns the result.
HLML_INLINE uint4 uint4_cshift_rights( const uint4* lhs, const uint32_t rhs )
{
	return HLML_CONSTRUCT( uint4 )
	{
		lhs->x >> rhs,
		lhs->y >> rhs,
		lhs->z >> rhs,
		lhs->w >> rhs
	};
}

// Performs a component-wise bitwise >> against the two vectors and returns the result.
HLML_INLINE uint4 uint4_cshift_rightv( const uint4* lhs, const uint4* rhs )
{
	return HLML_CONSTRUCT( uint4 )
	{
		lhs->x >> rhs->x,
		lhs->y >> rhs->y,
		lhs->z >> rhs->z,
		lhs->w >> rhs->w
	};
}

// Performs a uint4_min function on each component of the vector.
HLML_INLINE uint4 uint4_min( const uint4* x, const uint4* y )
{
	return HLML_CONSTRUCT( uint4 )
	{
		minu( x->x, y->x ),
		minu( x->y, y->y ),
		minu( x->z, y->z ),
		minu( x->w, y->w )
	};
}

// Performs a uint4_max function on each component of the vector.
HLML_INLINE uint4 uint4_max( const uint4* x, const uint4* y )
{
	return HLML_CONSTRUCT( uint4 )
	{
		maxu( x->x, y->x ),
		maxu( x->y, y->y ),
		maxu( x->z, y->z ),
		maxu( x->w, y->w )
	};
}

// Performs a uint4_clamp function on each component of the vector.
HLML_INLINE uint4 uint4_clamp( const uint4* x, const uint4* low, const uint4* high )
{
	return HLML_CONSTRUCT( uint4 )
	{
		clampu( x->x, low->x, high->x ),
		clampu( x->y, low->y, high->y ),
		clampu( x->z, low->z, high->z ),
		clampu( x->w, low->w, high->w )
	};
}

// Performs a uint4_saturate function on each component of the vector.
HLML_INLINE uint4 uint4_saturate( const uint4* x )
{
	return HLML_CONSTRUCT( uint4 )
	{
		saturateu( x->x ),
		saturateu( x->y ),
		saturateu( x->z ),
		saturateu( x->w )
	};
}

// Returns the magnitude of vector squared.
HLML_INLINE float uint4_lengthsq( const uint4* vec )
{
	return (float)( ( vec->x * vec->x ) + ( vec->y * vec->y ) + ( vec->z * vec->z ) + ( vec->w * vec->w ) );
}

// Returns the magnitude of the vector.
HLML_INLINE float uint4_length( const uint4* vec )
{
	return sqrtf( uint4_lengthsq( vec ) );
}

// Returns the dot product of the two vectors.
HLML_INLINE uint32_t uint4_dot( const uint4* lhs, const uint4* rhs )
{
	return ( lhs->x * rhs->x ) + ( lhs->y * rhs->y ) + ( lhs->z * rhs->z ) + ( lhs->w * rhs->w );
}

// Returns a 32 bit integer containing each component of the vector at each byte (where the X component contains the left-most byte).
HLML_INLINE uint32_t uint4_pack( const uint4* vec )
{
	return ( vec->x << 24 ) | ( vec->y << 16 ) | ( vec->z << 8 ) | ( vec->w );
}

// Returns a 4-component int vector where each component contains each byte of the integer (where the X component contains the left-most byte).
HLML_INLINE uint4 uint4_unpack( const uint32_t x )
{
	return HLML_CONSTRUCT( uint4 )
	{
		( x >> 24 ) & 0xFF,
		( x >> 16 ) & 0xFF,
		( x >> 8 ) & 0xFF,
		( x >> 0 ) & 0xFF
	};
}

// float2
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool float2_equals( const float2* lhs, const float2* rhs )
{
	return
		floateq( lhs->x, rhs->x ) &&
		floateq( lhs->y, rhs->y );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool float2_not_equals( const float2* lhs, const float2* rhs )
{
	return !float2_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two vectors and returns the result.
HLML_INLINE bool2 float2_less_than( const float2* lhs, const float2* rhs )
{
	return HLML_CONSTRUCT( bool2 )
	{
		lhs->x < rhs->x,
		lhs->y < rhs->y
	};
}

// Performs a component-wise '<=' check against the two vectors and returns the result.
HLML_INLINE bool2 float2_less_than_equal( const float2* lhs, const float2* rhs )
{
	return HLML_CONSTRUCT( bool2 )
	{
		lhs->x <= rhs->x,
		lhs->y <= rhs->y
	};
}

// Performs a component-wise '>' check against the two vectors and returns the result.
HLML_INLINE bool2 float2_greater_than( const float2* lhs, const float2* rhs )
{
	return HLML_CONSTRUCT( bool2 )
	{
		lhs->x > rhs->x,
		lhs->y > rhs->y
	};
}

// Performs a component-wise '>=' check against the two vectors and returns the result.
HLML_INLINE bool2 float2_greater_than_equal( const float2* lhs, const float2* rhs )
{
	return HLML_CONSTRUCT( bool2 )
	{
		lhs->x >= rhs->x,
		lhs->y >= rhs->y
	};
}

// Performs a component-wise + on the vector by the scalar and returns the result.
HLML_INLINE float2 float2_cadds( const float2* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float2 )
	{
		lhs->x + rhs,
		lhs->y + rhs
	};
}

// Performs a component-wise + against the two vectors and returns the result.
HLML_INLINE float2 float2_caddv( const float2* lhs, const float2* rhs )
{
	return HLML_CONSTRUCT( float2 )
	{
		lhs->x + rhs->x,
		lhs->y + rhs->y
	};
}

// Performs a component-wise - on the vector by the scalar and returns the result.
HLML_INLINE float2 float2_csubs( const float2* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float2 )
	{
		lhs->x - rhs,
		lhs->y - rhs
	};
}

// Performs a component-wise - against the two vectors and returns the result.
HLML_INLINE float2 float2_csubv( const float2* lhs, const float2* rhs )
{
	return HLML_CONSTRUCT( float2 )
	{
		lhs->x - rhs->x,
		lhs->y - rhs->y
	};
}

// Performs a component-wise * on the vector by the scalar and returns the result.
HLML_INLINE float2 float2_cmuls( const float2* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float2 )
	{
		lhs->x * rhs,
		lhs->y * rhs
	};
}

// Performs a component-wise * against the two vectors and returns the result.
HLML_INLINE float2 float2_cmulv( const float2* lhs, const float2* rhs )
{
	return HLML_CONSTRUCT( float2 )
	{
		lhs->x * rhs->x,
		lhs->y * rhs->y
	};
}

// Performs a component-wise / on the vector by the scalar and returns the result.
HLML_INLINE float2 float2_cdivs( const float2* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float2 )
	{
		lhs->x / rhs,
		lhs->y / rhs
	};
}

// Performs a component-wise / against the two vectors and returns the result.
HLML_INLINE float2 float2_cdivv( const float2* lhs, const float2* rhs )
{
	return HLML_CONSTRUCT( float2 )
	{
		lhs->x / rhs->x,
		lhs->y / rhs->y
	};
}

// Performs a float2_sign function on each component of the vector.
HLML_INLINE int2 float2_sign( const float2* x )
{
	return HLML_CONSTRUCT( int2 )
	{
		signf( x->x ),
		signf( x->y )
	};
}

// Performs a float2_min function on each component of the vector.
HLML_INLINE float2 float2_min( const float2* x, const float2* y )
{
	return HLML_CONSTRUCT( float2 )
	{
		minf( x->x, y->x ),
		minf( x->y, y->y )
	};
}

// Performs a float2_max function on each component of the vector.
HLML_INLINE float2 float2_max( const float2* x, const float2* y )
{
	return HLML_CONSTRUCT( float2 )
	{
		maxf( x->x, y->x ),
		maxf( x->y, y->y )
	};
}

// Performs a float2_clamp function on each component of the vector.
HLML_INLINE float2 float2_clamp( const float2* x, const float2* low, const float2* high )
{
	return HLML_CONSTRUCT( float2 )
	{
		clampf( x->x, low->x, high->x ),
		clampf( x->y, low->y, high->y )
	};
}

// Performs a float2_saturate function on each component of the vector.
HLML_INLINE float2 float2_saturate( const float2* x )
{
	return HLML_CONSTRUCT( float2 )
	{
		saturatef( x->x ),
		saturatef( x->y )
	};
}

// Performs a float2_lerp function on each component of the vector.
HLML_INLINE float2 float2_lerp( const float2* lhs, const float2* rhs, const float t )
{
	return HLML_CONSTRUCT( float2 )
	{
		lerpf( lhs->x, rhs->x, t ),
		lerpf( lhs->y, rhs->y, t )
	};
}

// Returns the magnitude of vector squared.
HLML_INLINE float float2_lengthsq( const float2* vec )
{
	return ( vec->x * vec->x ) + ( vec->y * vec->y );
}

// Returns the magnitude of the vector.
HLML_INLINE float float2_length( const float2* vec )
{
	return sqrtf( float2_lengthsq( vec ) );
}

// Normalizes the vector.
HLML_INLINE void float2_normalize( float2* vec )
{
	float invlen = 1.0f / float2_length( vec );

	*vec = float2_cmuls( vec, invlen );
}

// Returns a normalized copy of the vector.
HLML_INLINE float2 float2_normalized( const float2* vec )
{
	float invlen = 1.0f / float2_length( vec );

	return float2_cmuls( vec, invlen );
}

// Returns the dot product of the two vectors.
HLML_INLINE float float2_dot( const float2* lhs, const float2* rhs )
{
	return ( lhs->x * rhs->x ) + ( lhs->y * rhs->y );
}

// Returns the angle (in degrees) between the two vectors.
HLML_INLINE float float2_angle( const float2* lhs, const float2* rhs )
{
	float2 lhs_unit = float2_normalized( lhs );
	float2 rhs_unit = float2_normalized( rhs );
	return degreesf( acosf( float2_dot( &lhs_unit, &rhs_unit ) ) );
}

// Returns the squared distance between the two vectors.
HLML_INLINE float float2_distancesq( const float2* lhs, const float2* rhs )
{
	float2 delta = float2_csubv( lhs, rhs );
	return float2_lengthsq( &delta );
}

// Returns the distance between the two vectors.
HLML_INLINE float float2_distance( const float2* lhs, const float2* rhs )
{
	float2 delta = float2_csubv( lhs, rhs );
	return float2_length( &delta );
}

// float3
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool float3_equals( const float3* lhs, const float3* rhs )
{
	return
		floateq( lhs->x, rhs->x ) &&
		floateq( lhs->y, rhs->y ) &&
		floateq( lhs->z, rhs->z );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool float3_not_equals( const float3* lhs, const float3* rhs )
{
	return !float3_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two vectors and returns the result.
HLML_INLINE bool3 float3_less_than( const float3* lhs, const float3* rhs )
{
	return HLML_CONSTRUCT( bool3 )
	{
		lhs->x < rhs->x,
		lhs->y < rhs->y,
		lhs->z < rhs->z
	};
}

// Performs a component-wise '<=' check against the two vectors and returns the result.
HLML_INLINE bool3 float3_less_than_equal( const float3* lhs, const float3* rhs )
{
	return HLML_CONSTRUCT( bool3 )
	{
		lhs->x <= rhs->x,
		lhs->y <= rhs->y,
		lhs->z <= rhs->z
	};
}

// Performs a component-wise '>' check against the two vectors and returns the result.
HLML_INLINE bool3 float3_greater_than( const float3* lhs, const float3* rhs )
{
	return HLML_CONSTRUCT( bool3 )
	{
		lhs->x > rhs->x,
		lhs->y > rhs->y,
		lhs->z > rhs->z
	};
}

// Performs a component-wise '>=' check against the two vectors and returns the result.
HLML_INLINE bool3 float3_greater_than_equal( const float3* lhs, const float3* rhs )
{
	return HLML_CONSTRUCT( bool3 )
	{
		lhs->x >= rhs->x,
		lhs->y >= rhs->y,
		lhs->z >= rhs->z
	};
}

// Performs a component-wise + on the vector by the scalar and returns the result.
HLML_INLINE float3 float3_cadds( const float3* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float3 )
	{
		lhs->x + rhs,
		lhs->y + rhs,
		lhs->z + rhs
	};
}

// Performs a component-wise + against the two vectors and returns the result.
HLML_INLINE float3 float3_caddv( const float3* lhs, const float3* rhs )
{
	return HLML_CONSTRUCT( float3 )
	{
		lhs->x + rhs->x,
		lhs->y + rhs->y,
		lhs->z + rhs->z
	};
}

// Performs a component-wise - on the vector by the scalar and returns the result.
HLML_INLINE float3 float3_csubs( const float3* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float3 )
	{
		lhs->x - rhs,
		lhs->y - rhs,
		lhs->z - rhs
	};
}

// Performs a component-wise - against the two vectors and returns the result.
HLML_INLINE float3 float3_csubv( const float3* lhs, const float3* rhs )
{
	return HLML_CONSTRUCT( float3 )
	{
		lhs->x - rhs->x,
		lhs->y - rhs->y,
		lhs->z - rhs->z
	};
}

// Performs a component-wise * on the vector by the scalar and returns the result.
HLML_INLINE float3 float3_cmuls( const float3* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float3 )
	{
		lhs->x * rhs,
		lhs->y * rhs,
		lhs->z * rhs
	};
}

// Performs a component-wise * against the two vectors and returns the result.
HLML_INLINE float3 float3_cmulv( const float3* lhs, const float3* rhs )
{
	return HLML_CONSTRUCT( float3 )
	{
		lhs->x * rhs->x,
		lhs->y * rhs->y,
		lhs->z * rhs->z
	};
}

// Performs a component-wise / on the vector by the scalar and returns the result.
HLML_INLINE float3 float3_cdivs( const float3* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float3 )
	{
		lhs->x / rhs,
		lhs->y / rhs,
		lhs->z / rhs
	};
}

// Performs a component-wise / against the two vectors and returns the result.
HLML_INLINE float3 float3_cdivv( const float3* lhs, const float3* rhs )
{
	return HLML_CONSTRUCT( float3 )
	{
		lhs->x / rhs->x,
		lhs->y / rhs->y,
		lhs->z / rhs->z
	};
}

// Performs a float3_sign function on each component of the vector.
HLML_INLINE int3 float3_sign( const float3* x )
{
	return HLML_CONSTRUCT( int3 )
	{
		signf( x->x ),
		signf( x->y ),
		signf( x->z )
	};
}

// Performs a float3_min function on each component of the vector.
HLML_INLINE float3 float3_min( const float3* x, const float3* y )
{
	return HLML_CONSTRUCT( float3 )
	{
		minf( x->x, y->x ),
		minf( x->y, y->y ),
		minf( x->z, y->z )
	};
}

// Performs a float3_max function on each component of the vector.
HLML_INLINE float3 float3_max( const float3* x, const float3* y )
{
	return HLML_CONSTRUCT( float3 )
	{
		maxf( x->x, y->x ),
		maxf( x->y, y->y ),
		maxf( x->z, y->z )
	};
}

// Performs a float3_clamp function on each component of the vector.
HLML_INLINE float3 float3_clamp( const float3* x, const float3* low, const float3* high )
{
	return HLML_CONSTRUCT( float3 )
	{
		clampf( x->x, low->x, high->x ),
		clampf( x->y, low->y, high->y ),
		clampf( x->z, low->z, high->z )
	};
}

// Performs a float3_saturate function on each component of the vector.
HLML_INLINE float3 float3_saturate( const float3* x )
{
	return HLML_CONSTRUCT( float3 )
	{
		saturatef( x->x ),
		saturatef( x->y ),
		saturatef( x->z )
	};
}

// Performs a float3_lerp function on each component of the vector.
HLML_INLINE float3 float3_lerp( const float3* lhs, const float3* rhs, const float t )
{
	return HLML_CONSTRUCT( float3 )
	{
		lerpf( lhs->x, rhs->x, t ),
		lerpf( lhs->y, rhs->y, t ),
		lerpf( lhs->z, rhs->z, t )
	};
}

// Returns the magnitude of vector squared.
HLML_INLINE float float3_lengthsq( const float3* vec )
{
	return ( vec->x * vec->x ) + ( vec->y * vec->y ) + ( vec->z * vec->z );
}

// Returns the magnitude of the vector.
HLML_INLINE float float3_length( const float3* vec )
{
	return sqrtf( float3_lengthsq( vec ) );
}

// Normalizes the vector.
HLML_INLINE void float3_normalize( float3* vec )
{
	float invlen = 1.0f / float3_length( vec );

	*vec = float3_cmuls( vec, invlen );
}

// Returns a normalized copy of the vector.
HLML_INLINE float3 float3_normalized( const float3* vec )
{
	float invlen = 1.0f / float3_length( vec );

	return float3_cmuls( vec, invlen );
}

// Returns the dot product of the two vectors.
HLML_INLINE float float3_dot( const float3* lhs, const float3* rhs )
{
	return ( lhs->x * rhs->x ) + ( lhs->y * rhs->y ) + ( lhs->z * rhs->z );
}

// Returns a vector perpendicular to the two vectors.
HLML_INLINE float3 float3_cross( const float3* lhs, const float3* rhs )
{
	return HLML_CONSTRUCT( float3 )
	{
		( lhs->y * rhs->z ) - ( lhs->z * rhs->y ),
		( lhs->z * rhs->x ) - ( lhs->x * rhs->z ),
		( lhs->x * rhs->y ) - ( lhs->y * rhs->x )
	};
}

// Returns the angle (in degrees) between the two vectors.
HLML_INLINE float float3_angle( const float3* lhs, const float3* rhs )
{
	float3 lhs_unit = float3_normalized( lhs );
	float3 rhs_unit = float3_normalized( rhs );
	return degreesf( acosf( float3_dot( &lhs_unit, &rhs_unit ) ) );
}

// Returns the squared distance between the two vectors.
HLML_INLINE float float3_distancesq( const float3* lhs, const float3* rhs )
{
	float3 delta = float3_csubv( lhs, rhs );
	return float3_lengthsq( &delta );
}

// Returns the distance between the two vectors.
HLML_INLINE float float3_distance( const float3* lhs, const float3* rhs )
{
	float3 delta = float3_csubv( lhs, rhs );
	return float3_length( &delta );
}

// float4
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool float4_equals( const float4* lhs, const float4* rhs )
{
	return
		floateq( lhs->x, rhs->x ) &&
		floateq( lhs->y, rhs->y ) &&
		floateq( lhs->z, rhs->z ) &&
		floateq( lhs->w, rhs->w );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool float4_not_equals( const float4* lhs, const float4* rhs )
{
	return !float4_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two vectors and returns the result.
HLML_INLINE bool4 float4_less_than( const float4* lhs, const float4* rhs )
{
	return HLML_CONSTRUCT( bool4 )
	{
		lhs->x < rhs->x,
		lhs->y < rhs->y,
		lhs->z < rhs->z,
		lhs->w < rhs->w
	};
}

// Performs a component-wise '<=' check against the two vectors and returns the result.
HLML_INLINE bool4 float4_less_than_equal( const float4* lhs, const float4* rhs )
{
	return HLML_CONSTRUCT( bool4 )
	{
		lhs->x <= rhs->x,
		lhs->y <= rhs->y,
		lhs->z <= rhs->z,
		lhs->w <= rhs->w
	};
}

// Performs a component-wise '>' check against the two vectors and returns the result.
HLML_INLINE bool4 float4_greater_than( const float4* lhs, const float4* rhs )
{
	return HLML_CONSTRUCT( bool4 )
	{
		lhs->x > rhs->x,
		lhs->y > rhs->y,
		lhs->z > rhs->z,
		lhs->w > rhs->w
	};
}

// Performs a component-wise '>=' check against the two vectors and returns the result.
HLML_INLINE bool4 float4_greater_than_equal( const float4* lhs, const float4* rhs )
{
	return HLML_CONSTRUCT( bool4 )
	{
		lhs->x >= rhs->x,
		lhs->y >= rhs->y,
		lhs->z >= rhs->z,
		lhs->w >= rhs->w
	};
}

// Performs a component-wise + on the vector by the scalar and returns the result.
HLML_INLINE float4 float4_cadds( const float4* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float4 )
	{
		lhs->x + rhs,
		lhs->y + rhs,
		lhs->z + rhs,
		lhs->w + rhs
	};
}

// Performs a component-wise + against the two vectors and returns the result.
HLML_INLINE float4 float4_caddv( const float4* lhs, const float4* rhs )
{
	return HLML_CONSTRUCT( float4 )
	{
		lhs->x + rhs->x,
		lhs->y + rhs->y,
		lhs->z + rhs->z,
		lhs->w + rhs->w
	};
}

// Performs a component-wise - on the vector by the scalar and returns the result.
HLML_INLINE float4 float4_csubs( const float4* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float4 )
	{
		lhs->x - rhs,
		lhs->y - rhs,
		lhs->z - rhs,
		lhs->w - rhs
	};
}

// Performs a component-wise - against the two vectors and returns the result.
HLML_INLINE float4 float4_csubv( const float4* lhs, const float4* rhs )
{
	return HLML_CONSTRUCT( float4 )
	{
		lhs->x - rhs->x,
		lhs->y - rhs->y,
		lhs->z - rhs->z,
		lhs->w - rhs->w
	};
}

// Performs a component-wise * on the vector by the scalar and returns the result.
HLML_INLINE float4 float4_cmuls( const float4* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float4 )
	{
		lhs->x * rhs,
		lhs->y * rhs,
		lhs->z * rhs,
		lhs->w * rhs
	};
}

// Performs a component-wise * against the two vectors and returns the result.
HLML_INLINE float4 float4_cmulv( const float4* lhs, const float4* rhs )
{
	return HLML_CONSTRUCT( float4 )
	{
		lhs->x * rhs->x,
		lhs->y * rhs->y,
		lhs->z * rhs->z,
		lhs->w * rhs->w
	};
}

// Performs a component-wise / on the vector by the scalar and returns the result.
HLML_INLINE float4 float4_cdivs( const float4* lhs, const float rhs )
{
	return HLML_CONSTRUCT( float4 )
	{
		lhs->x / rhs,
		lhs->y / rhs,
		lhs->z / rhs,
		lhs->w / rhs
	};
}

// Performs a component-wise / against the two vectors and returns the result.
HLML_INLINE float4 float4_cdivv( const float4* lhs, const float4* rhs )
{
	return HLML_CONSTRUCT( float4 )
	{
		lhs->x / rhs->x,
		lhs->y / rhs->y,
		lhs->z / rhs->z,
		lhs->w / rhs->w
	};
}

// Performs a float4_sign function on each component of the vector.
HLML_INLINE int4 float4_sign( const float4* x )
{
	return HLML_CONSTRUCT( int4 )
	{
		signf( x->x ),
		signf( x->y ),
		signf( x->z ),
		signf( x->w )
	};
}

// Performs a float4_min function on each component of the vector.
HLML_INLINE float4 float4_min( const float4* x, const float4* y )
{
	return HLML_CONSTRUCT( float4 )
	{
		minf( x->x, y->x ),
		minf( x->y, y->y ),
		minf( x->z, y->z ),
		minf( x->w, y->w )
	};
}

// Performs a float4_max function on each component of the vector.
HLML_INLINE float4 float4_max( const float4* x, const float4* y )
{
	return HLML_CONSTRUCT( float4 )
	{
		maxf( x->x, y->x ),
		maxf( x->y, y->y ),
		maxf( x->z, y->z ),
		maxf( x->w, y->w )
	};
}

// Performs a float4_clamp function on each component of the vector.
HLML_INLINE float4 float4_clamp( const float4* x, const float4* low, const float4* high )
{
	return HLML_CONSTRUCT( float4 )
	{
		clampf( x->x, low->x, high->x ),
		clampf( x->y, low->y, high->y ),
		clampf( x->z, low->z, high->z ),
		clampf( x->w, low->w, high->w )
	};
}

// Performs a float4_saturate function on each component of the vector.
HLML_INLINE float4 float4_saturate( const float4* x )
{
	return HLML_CONSTRUCT( float4 )
	{
		saturatef( x->x ),
		saturatef( x->y ),
		saturatef( x->z ),
		saturatef( x->w )
	};
}

// Performs a float4_lerp function on each component of the vector.
HLML_INLINE float4 float4_lerp( const float4* lhs, const float4* rhs, const float t )
{
	return HLML_CONSTRUCT( float4 )
	{
		lerpf( lhs->x, rhs->x, t ),
		lerpf( lhs->y, rhs->y, t ),
		lerpf( lhs->z, rhs->z, t ),
		lerpf( lhs->w, rhs->w, t )
	};
}

// Returns the magnitude of vector squared.
HLML_INLINE float float4_lengthsq( const float4* vec )
{
	return ( vec->x * vec->x ) + ( vec->y * vec->y ) + ( vec->z * vec->z ) + ( vec->w * vec->w );
}

// Returns the magnitude of the vector.
HLML_INLINE float float4_length( const float4* vec )
{
	return sqrtf( float4_lengthsq( vec ) );
}

// Normalizes the vector.
HLML_INLINE void float4_normalize( float4* vec )
{
	float invlen = 1.0f / float4_length( vec );

	*vec = float4_cmuls( vec, invlen );
}

// Returns a normalized copy of the vector.
HLML_INLINE float4 float4_normalized( const float4* vec )
{
	float invlen = 1.0f / float4_length( vec );

	return float4_cmuls( vec, invlen );
}

// Returns the dot product of the two vectors.
HLML_INLINE float float4_dot( const float4* lhs, const float4* rhs )
{
	return ( lhs->x * rhs->x ) + ( lhs->y * rhs->y ) + ( lhs->z * rhs->z ) + ( lhs->w * rhs->w );
}

// Returns the angle (in degrees) between the two vectors.
HLML_INLINE float float4_angle( const float4* lhs, const float4* rhs )
{
	float4 lhs_unit = float4_normalized( lhs );
	float4 rhs_unit = float4_normalized( rhs );
	return degreesf( acosf( float4_dot( &lhs_unit, &rhs_unit ) ) );
}

// double2
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool double2_equals( const double2* lhs, const double2* rhs )
{
	return
		doubleeq( lhs->x, rhs->x ) &&
		doubleeq( lhs->y, rhs->y );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool double2_not_equals( const double2* lhs, const double2* rhs )
{
	return !double2_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two vectors and returns the result.
HLML_INLINE bool2 double2_less_than( const double2* lhs, const double2* rhs )
{
	return HLML_CONSTRUCT( bool2 )
	{
		lhs->x < rhs->x,
		lhs->y < rhs->y
	};
}

// Performs a component-wise '<=' check against the two vectors and returns the result.
HLML_INLINE bool2 double2_less_than_equal( const double2* lhs, const double2* rhs )
{
	return HLML_CONSTRUCT( bool2 )
	{
		lhs->x <= rhs->x,
		lhs->y <= rhs->y
	};
}

// Performs a component-wise '>' check against the two vectors and returns the result.
HLML_INLINE bool2 double2_greater_than( const double2* lhs, const double2* rhs )
{
	return HLML_CONSTRUCT( bool2 )
	{
		lhs->x > rhs->x,
		lhs->y > rhs->y
	};
}

// Performs a component-wise '>=' check against the two vectors and returns the result.
HLML_INLINE bool2 double2_greater_than_equal( const double2* lhs, const double2* rhs )
{
	return HLML_CONSTRUCT( bool2 )
	{
		lhs->x >= rhs->x,
		lhs->y >= rhs->y
	};
}

// Performs a component-wise + on the vector by the scalar and returns the result.
HLML_INLINE double2 double2_cadds( const double2* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double2 )
	{
		lhs->x + rhs,
		lhs->y + rhs
	};
}

// Performs a component-wise + against the two vectors and returns the result.
HLML_INLINE double2 double2_caddv( const double2* lhs, const double2* rhs )
{
	return HLML_CONSTRUCT( double2 )
	{
		lhs->x + rhs->x,
		lhs->y + rhs->y
	};
}

// Performs a component-wise - on the vector by the scalar and returns the result.
HLML_INLINE double2 double2_csubs( const double2* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double2 )
	{
		lhs->x - rhs,
		lhs->y - rhs
	};
}

// Performs a component-wise - against the two vectors and returns the result.
HLML_INLINE double2 double2_csubv( const double2* lhs, const double2* rhs )
{
	return HLML_CONSTRUCT( double2 )
	{
		lhs->x - rhs->x,
		lhs->y - rhs->y
	};
}

// Performs a component-wise * on the vector by the scalar and returns the result.
HLML_INLINE double2 double2_cmuls( const double2* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double2 )
	{
		lhs->x * rhs,
		lhs->y * rhs
	};
}

// Performs a component-wise * against the two vectors and returns the result.
HLML_INLINE double2 double2_cmulv( const double2* lhs, const double2* rhs )
{
	return HLML_CONSTRUCT( double2 )
	{
		lhs->x * rhs->x,
		lhs->y * rhs->y
	};
}

// Performs a component-wise / on the vector by the scalar and returns the result.
HLML_INLINE double2 double2_cdivs( const double2* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double2 )
	{
		lhs->x / rhs,
		lhs->y / rhs
	};
}

// Performs a component-wise / against the two vectors and returns the result.
HLML_INLINE double2 double2_cdivv( const double2* lhs, const double2* rhs )
{
	return HLML_CONSTRUCT( double2 )
	{
		lhs->x / rhs->x,
		lhs->y / rhs->y
	};
}

// Performs a double2_sign function on each component of the vector.
HLML_INLINE int2 double2_sign( const double2* x )
{
	return HLML_CONSTRUCT( int2 )
	{
		signd( x->x ),
		signd( x->y )
	};
}

// Performs a double2_min function on each component of the vector.
HLML_INLINE double2 double2_min( const double2* x, const double2* y )
{
	return HLML_CONSTRUCT( double2 )
	{
		mind( x->x, y->x ),
		mind( x->y, y->y )
	};
}

// Performs a double2_max function on each component of the vector.
HLML_INLINE double2 double2_max( const double2* x, const double2* y )
{
	return HLML_CONSTRUCT( double2 )
	{
		maxd( x->x, y->x ),
		maxd( x->y, y->y )
	};
}

// Performs a double2_clamp function on each component of the vector.
HLML_INLINE double2 double2_clamp( const double2* x, const double2* low, const double2* high )
{
	return HLML_CONSTRUCT( double2 )
	{
		clampd( x->x, low->x, high->x ),
		clampd( x->y, low->y, high->y )
	};
}

// Performs a double2_saturate function on each component of the vector.
HLML_INLINE double2 double2_saturate( const double2* x )
{
	return HLML_CONSTRUCT( double2 )
	{
		saturated( x->x ),
		saturated( x->y )
	};
}

// Performs a double2_lerp function on each component of the vector.
HLML_INLINE double2 double2_lerp( const double2* lhs, const double2* rhs, const double t )
{
	return HLML_CONSTRUCT( double2 )
	{
		lerpd( lhs->x, rhs->x, t ),
		lerpd( lhs->y, rhs->y, t )
	};
}

// Returns the magnitude of vector squared.
HLML_INLINE double double2_lengthsq( const double2* vec )
{
	return ( vec->x * vec->x ) + ( vec->y * vec->y );
}

// Returns the magnitude of the vector.
HLML_INLINE double double2_length( const double2* vec )
{
	return sqrt( double2_lengthsq( vec ) );
}

// Normalizes the vector.
HLML_INLINE void double2_normalize( double2* vec )
{
	double invlen = 1.0 / double2_length( vec );

	*vec = double2_cmuls( vec, invlen );
}

// Returns a normalized copy of the vector.
HLML_INLINE double2 double2_normalized( const double2* vec )
{
	double invlen = 1.0 / double2_length( vec );

	return double2_cmuls( vec, invlen );
}

// Returns the dot product of the two vectors.
HLML_INLINE double double2_dot( const double2* lhs, const double2* rhs )
{
	return ( lhs->x * rhs->x ) + ( lhs->y * rhs->y );
}

// Returns the angle (in degrees) between the two vectors.
HLML_INLINE double double2_angle( const double2* lhs, const double2* rhs )
{
	double2 lhs_unit = double2_normalized( lhs );
	double2 rhs_unit = double2_normalized( rhs );
	return degreesd( acos( double2_dot( &lhs_unit, &rhs_unit ) ) );
}

// Returns the squared distance between the two vectors.
HLML_INLINE double double2_distancesq( const double2* lhs, const double2* rhs )
{
	double2 delta = double2_csubv( lhs, rhs );
	return double2_lengthsq( &delta );
}

// Returns the distance between the two vectors.
HLML_INLINE double double2_distance( const double2* lhs, const double2* rhs )
{
	double2 delta = double2_csubv( lhs, rhs );
	return double2_length( &delta );
}

// double3
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool double3_equals( const double3* lhs, const double3* rhs )
{
	return
		doubleeq( lhs->x, rhs->x ) &&
		doubleeq( lhs->y, rhs->y ) &&
		doubleeq( lhs->z, rhs->z );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool double3_not_equals( const double3* lhs, const double3* rhs )
{
	return !double3_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two vectors and returns the result.
HLML_INLINE bool3 double3_less_than( const double3* lhs, const double3* rhs )
{
	return HLML_CONSTRUCT( bool3 )
	{
		lhs->x < rhs->x,
		lhs->y < rhs->y,
		lhs->z < rhs->z
	};
}

// Performs a component-wise '<=' check against the two vectors and returns the result.
HLML_INLINE bool3 double3_less_than_equal( const double3* lhs, const double3* rhs )
{
	return HLML_CONSTRUCT( bool3 )
	{
		lhs->x <= rhs->x,
		lhs->y <= rhs->y,
		lhs->z <= rhs->z
	};
}

// Performs a component-wise '>' check against the two vectors and returns the result.
HLML_INLINE bool3 double3_greater_than( const double3* lhs, const double3* rhs )
{
	return HLML_CONSTRUCT( bool3 )
	{
		lhs->x > rhs->x,
		lhs->y > rhs->y,
		lhs->z > rhs->z
	};
}

// Performs a component-wise '>=' check against the two vectors and returns the result.
HLML_INLINE bool3 double3_greater_than_equal( const double3* lhs, const double3* rhs )
{
	return HLML_CONSTRUCT( bool3 )
	{
		lhs->x >= rhs->x,
		lhs->y >= rhs->y,
		lhs->z >= rhs->z
	};
}

// Performs a component-wise + on the vector by the scalar and returns the result.
HLML_INLINE double3 double3_cadds( const double3* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double3 )
	{
		lhs->x + rhs,
		lhs->y + rhs,
		lhs->z + rhs
	};
}

// Performs a component-wise + against the two vectors and returns the result.
HLML_INLINE double3 double3_caddv( const double3* lhs, const double3* rhs )
{
	return HLML_CONSTRUCT( double3 )
	{
		lhs->x + rhs->x,
		lhs->y + rhs->y,
		lhs->z + rhs->z
	};
}

// Performs a component-wise - on the vector by the scalar and returns the result.
HLML_INLINE double3 double3_csubs( const double3* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double3 )
	{
		lhs->x - rhs,
		lhs->y - rhs,
		lhs->z - rhs
	};
}

// Performs a component-wise - against the two vectors and returns the result.
HLML_INLINE double3 double3_csubv( const double3* lhs, const double3* rhs )
{
	return HLML_CONSTRUCT( double3 )
	{
		lhs->x - rhs->x,
		lhs->y - rhs->y,
		lhs->z - rhs->z
	};
}

// Performs a component-wise * on the vector by the scalar and returns the result.
HLML_INLINE double3 double3_cmuls( const double3* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double3 )
	{
		lhs->x * rhs,
		lhs->y * rhs,
		lhs->z * rhs
	};
}

// Performs a component-wise * against the two vectors and returns the result.
HLML_INLINE double3 double3_cmulv( const double3* lhs, const double3* rhs )
{
	return HLML_CONSTRUCT( double3 )
	{
		lhs->x * rhs->x,
		lhs->y * rhs->y,
		lhs->z * rhs->z
	};
}

// Performs a component-wise / on the vector by the scalar and returns the result.
HLML_INLINE double3 double3_cdivs( const double3* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double3 )
	{
		lhs->x / rhs,
		lhs->y / rhs,
		lhs->z / rhs
	};
}

// Performs a component-wise / against the two vectors and returns the result.
HLML_INLINE double3 double3_cdivv( const double3* lhs, const double3* rhs )
{
	return HLML_CONSTRUCT( double3 )
	{
		lhs->x / rhs->x,
		lhs->y / rhs->y,
		lhs->z / rhs->z
	};
}

// Performs a double3_sign function on each component of the vector.
HLML_INLINE int3 double3_sign( const double3* x )
{
	return HLML_CONSTRUCT( int3 )
	{
		signd( x->x ),
		signd( x->y ),
		signd( x->z )
	};
}

// Performs a double3_min function on each component of the vector.
HLML_INLINE double3 double3_min( const double3* x, const double3* y )
{
	return HLML_CONSTRUCT( double3 )
	{
		mind( x->x, y->x ),
		mind( x->y, y->y ),
		mind( x->z, y->z )
	};
}

// Performs a double3_max function on each component of the vector.
HLML_INLINE double3 double3_max( const double3* x, const double3* y )
{
	return HLML_CONSTRUCT( double3 )
	{
		maxd( x->x, y->x ),
		maxd( x->y, y->y ),
		maxd( x->z, y->z )
	};
}

// Performs a double3_clamp function on each component of the vector.
HLML_INLINE double3 double3_clamp( const double3* x, const double3* low, const double3* high )
{
	return HLML_CONSTRUCT( double3 )
	{
		clampd( x->x, low->x, high->x ),
		clampd( x->y, low->y, high->y ),
		clampd( x->z, low->z, high->z )
	};
}

// Performs a double3_saturate function on each component of the vector.
HLML_INLINE double3 double3_saturate( const double3* x )
{
	return HLML_CONSTRUCT( double3 )
	{
		saturated( x->x ),
		saturated( x->y ),
		saturated( x->z )
	};
}

// Performs a double3_lerp function on each component of the vector.
HLML_INLINE double3 double3_lerp( const double3* lhs, const double3* rhs, const double t )
{
	return HLML_CONSTRUCT( double3 )
	{
		lerpd( lhs->x, rhs->x, t ),
		lerpd( lhs->y, rhs->y, t ),
		lerpd( lhs->z, rhs->z, t )
	};
}

// Returns the magnitude of vector squared.
HLML_INLINE double double3_lengthsq( const double3* vec )
{
	return ( vec->x * vec->x ) + ( vec->y * vec->y ) + ( vec->z * vec->z );
}

// Returns the magnitude of the vector.
HLML_INLINE double double3_length( const double3* vec )
{
	return sqrt( double3_lengthsq( vec ) );
}

// Normalizes the vector.
HLML_INLINE void double3_normalize( double3* vec )
{
	double invlen = 1.0 / double3_length( vec );

	*vec = double3_cmuls( vec, invlen );
}

// Returns a normalized copy of the vector.
HLML_INLINE double3 double3_normalized( const double3* vec )
{
	double invlen = 1.0 / double3_length( vec );

	return double3_cmuls( vec, invlen );
}

// Returns the dot product of the two vectors.
HLML_INLINE double double3_dot( const double3* lhs, const double3* rhs )
{
	return ( lhs->x * rhs->x ) + ( lhs->y * rhs->y ) + ( lhs->z * rhs->z );
}

// Returns a vector perpendicular to the two vectors.
HLML_INLINE double3 double3_cross( const double3* lhs, const double3* rhs )
{
	return HLML_CONSTRUCT( double3 )
	{
		( lhs->y * rhs->z ) - ( lhs->z * rhs->y ),
		( lhs->z * rhs->x ) - ( lhs->x * rhs->z ),
		( lhs->x * rhs->y ) - ( lhs->y * rhs->x )
	};
}

// Returns the angle (in degrees) between the two vectors.
HLML_INLINE double double3_angle( const double3* lhs, const double3* rhs )
{
	double3 lhs_unit = double3_normalized( lhs );
	double3 rhs_unit = double3_normalized( rhs );
	return degreesd( acos( double3_dot( &lhs_unit, &rhs_unit ) ) );
}

// Returns the squared distance between the two vectors.
HLML_INLINE double double3_distancesq( const double3* lhs, const double3* rhs )
{
	double3 delta = double3_csubv( lhs, rhs );
	return double3_lengthsq( &delta );
}

// Returns the distance between the two vectors.
HLML_INLINE double double3_distance( const double3* lhs, const double3* rhs )
{
	double3 delta = double3_csubv( lhs, rhs );
	return double3_length( &delta );
}

// double4
// Returns true if the contents of 'lhs' are the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool double4_equals( const double4* lhs, const double4* rhs )
{
	return
		doubleeq( lhs->x, rhs->x ) &&
		doubleeq( lhs->y, rhs->y ) &&
		doubleeq( lhs->z, rhs->z ) &&
		doubleeq( lhs->w, rhs->w );
}

// Returns true if the contents of 'lhs' are NOT the same as the contents of 'rhs', otherwise returns false.
HLML_INLINE bool double4_not_equals( const double4* lhs, const double4* rhs )
{
	return !double4_equals( lhs, rhs );
}

// Performs a component-wise '<' check against the two vectors and returns the result.
HLML_INLINE bool4 double4_less_than( const double4* lhs, const double4* rhs )
{
	return HLML_CONSTRUCT( bool4 )
	{
		lhs->x < rhs->x,
		lhs->y < rhs->y,
		lhs->z < rhs->z,
		lhs->w < rhs->w
	};
}

// Performs a component-wise '<=' check against the two vectors and returns the result.
HLML_INLINE bool4 double4_less_than_equal( const double4* lhs, const double4* rhs )
{
	return HLML_CONSTRUCT( bool4 )
	{
		lhs->x <= rhs->x,
		lhs->y <= rhs->y,
		lhs->z <= rhs->z,
		lhs->w <= rhs->w
	};
}

// Performs a component-wise '>' check against the two vectors and returns the result.
HLML_INLINE bool4 double4_greater_than( const double4* lhs, const double4* rhs )
{
	return HLML_CONSTRUCT( bool4 )
	{
		lhs->x > rhs->x,
		lhs->y > rhs->y,
		lhs->z > rhs->z,
		lhs->w > rhs->w
	};
}

// Performs a component-wise '>=' check against the two vectors and returns the result.
HLML_INLINE bool4 double4_greater_than_equal( const double4* lhs, const double4* rhs )
{
	return HLML_CONSTRUCT( bool4 )
	{
		lhs->x >= rhs->x,
		lhs->y >= rhs->y,
		lhs->z >= rhs->z,
		lhs->w >= rhs->w
	};
}

// Performs a component-wise + on the vector by the scalar and returns the result.
HLML_INLINE double4 double4_cadds( const double4* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double4 )
	{
		lhs->x + rhs,
		lhs->y + rhs,
		lhs->z + rhs,
		lhs->w + rhs
	};
}

// Performs a component-wise + against the two vectors and returns the result.
HLML_INLINE double4 double4_caddv( const double4* lhs, const double4* rhs )
{
	return HLML_CONSTRUCT( double4 )
	{
		lhs->x + rhs->x,
		lhs->y + rhs->y,
		lhs->z + rhs->z,
		lhs->w + rhs->w
	};
}

// Performs a component-wise - on the vector by the scalar and returns the result.
HLML_INLINE double4 double4_csubs( const double4* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double4 )
	{
		lhs->x - rhs,
		lhs->y - rhs,
		lhs->z - rhs,
		lhs->w - rhs
	};
}

// Performs a component-wise - against the two vectors and returns the result.
HLML_INLINE double4 double4_csubv( const double4* lhs, const double4* rhs )
{
	return HLML_CONSTRUCT( double4 )
	{
		lhs->x - rhs->x,
		lhs->y - rhs->y,
		lhs->z - rhs->z,
		lhs->w - rhs->w
	};
}

// Performs a component-wise * on the vector by the scalar and returns the result.
HLML_INLINE double4 double4_cmuls( const double4* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double4 )
	{
		lhs->x * rhs,
		lhs->y * rhs,
		lhs->z * rhs,
		lhs->w * rhs
	};
}

// Performs a component-wise * against the two vectors and returns the result.
HLML_INLINE double4 double4_cmulv( const double4* lhs, const double4* rhs )
{
	return HLML_CONSTRUCT( double4 )
	{
		lhs->x * rhs->x,
		lhs->y * rhs->y,
		lhs->z * rhs->z,
		lhs->w * rhs->w
	};
}

// Performs a component-wise / on the vector by the scalar and returns the result.
HLML_INLINE double4 double4_cdivs( const double4* lhs, const double rhs )
{
	return HLML_CONSTRUCT( double4 )
	{
		lhs->x / rhs,
		lhs->y / rhs,
		lhs->z / rhs,
		lhs->w / rhs
	};
}

// Performs a component-wise / against the two vectors and returns the result.
HLML_INLINE double4 double4_cdivv( const double4* lhs, const double4* rhs )
{
	return HLML_CONSTRUCT( double4 )
	{
		lhs->x / rhs->x,
		lhs->y / rhs->y,
		lhs->z / rhs->z,
		lhs->w / rhs->w
	};
}

// Performs a double4_sign function on each component of the vector.
HLML_INLINE int4 double4_sign( const double4* x )
{
	return HLML_CONSTRUCT( int4 )
	{
		signd( x->x ),
		signd( x->y ),
		signd( x->z ),
		signd( x->w )
	};
}

// Performs a double4_min function on each component of the vector.
HLML_INLINE double4 double4_min( const double4* x, const double4* y )
{
	return HLML_CONSTRUCT( double4 )
	{
		mind( x->x, y->x ),
		mind( x->y, y->y ),
		mind( x->z, y->z ),
		mind( x->w, y->w )
	};
}

// Performs a double4_max function on each component of the vector.
HLML_INLINE double4 double4_max( const double4* x, const double4* y )
{
	return HLML_CONSTRUCT( double4 )
	{
		maxd( x->x, y->x ),
		maxd( x->y, y->y ),
		maxd( x->z, y->z ),
		maxd( x->w, y->w )
	};
}

// Performs a double4_clamp function on each component of the vector.
HLML_INLINE double4 double4_clamp( const double4* x, const double4* low, const double4* high )
{
	return HLML_CONSTRUCT( double4 )
	{
		clampd( x->x, low->x, high->x ),
		clampd( x->y, low->y, high->y ),
		clampd( x->z, low->z, high->z ),
		clampd( x->w, low->w, high->w )
	};
}

// Performs a double4_saturate function on each component of the vector.
HLML_INLINE double4 double4_saturate( const double4* x )
{
	return HLML_CONSTRUCT( double4 )
	{
		saturated( x->x ),
		saturated( x->y ),
		saturated( x->z ),
		saturated( x->w )
	};
}

// Performs a double4_lerp function on each component of the vector.
HLML_INLINE double4 double4_lerp( const double4* lhs, const double4* rhs, const double t )
{
	return HLML_CONSTRUCT( double4 )
	{
		lerpd( lhs->x, rhs->x, t ),
		lerpd( lhs->y, rhs->y, t ),
		lerpd( lhs->z, rhs->z, t ),
		lerpd( lhs->w, rhs->w, t )
	};
}

// Returns the magnitude of vector squared.
HLML_INLINE double double4_lengthsq( const double4* vec )
{
	return ( vec->x * vec->x ) + ( vec->y * vec->y ) + ( vec->z * vec->z ) + ( vec->w * vec->w );
}

// Returns the magnitude of the vector.
HLML_INLINE double double4_length( const double4* vec )
{
	return sqrt( double4_lengthsq( vec ) );
}

// Normalizes the vector.
HLML_INLINE void double4_normalize( double4* vec )
{
	double invlen = 1.0 / double4_length( vec );

	*vec = double4_cmuls( vec, invlen );
}

// Returns a normalized copy of the vector.
HLML_INLINE double4 double4_normalized( const double4* vec )
{
	double invlen = 1.0 / double4_length( vec );

	return double4_cmuls( vec, invlen );
}

// Returns the dot product of the two vectors.
HLML_INLINE double double4_dot( const double4* lhs, const double4* rhs )
{
	return ( lhs->x * rhs->x ) + ( lhs->y * rhs->y ) + ( lhs->z * rhs->z ) + ( lhs->w * rhs->w );
}

// Returns the angle (in degrees) between the two vectors.
HLML_INLINE double double4_angle( const double4* lhs, const double4* rhs )
{
	double4 lhs_unit = double4_normalized( lhs );
	double4 rhs_unit = double4_normalized( rhs );
	return degreesd( acos( double4_dot( &lhs_unit, &rhs_unit ) ) );
}

#ifdef __cplusplus
}
#endif
