/*
===========================================================================

HLML.

MIT License

Copyright (c) 2019 Dan Moody

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

===========================================================================
*/

// THIS FILE WAS AUTOMATICALLY GENERATED BY A TOOL.
// EDITING THIS FILE MAY CAUSE SIDE EFFECTS.
// DO SO AT YOUR OWN RISK.

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

#include "hlml_constants.h"
#include "hlml_defines.h"

#include <math.h>
#include <stdint.h>

#ifndef __cplusplus
#include <stdbool.h>
#endif

// int32_t
// Returns -1 if 'x' is < 0, 0 if 'x' == 0, or 1 if 'x' > 1.
HLML_INLINE int32_t signi( const int32_t x )
{
	return ( 0 < x ) - ( x < 0 );
}

// Returns 'x' if it's smaller than 'y', otherwise returns 'y'.
HLML_INLINE int32_t mini( const int32_t x, const int32_t y )
{
	return ( x < y ) ? x : y;
}

// Returns x if it's larger than 'y', otherwise returns 'y'.
HLML_INLINE int32_t maxi( const int32_t x, const int32_t y )
{
	return ( x > y ) ? x : y;
}

// If 'x' is lower than 'low' or higher than 'high' then returns 'low' or 'high' respectively, otherwise returns 'x'.
HLML_INLINE int32_t clampi( const int32_t x, const int32_t low, const int32_t high )
{
	return mini( maxi( x, low ), high );
}

// Returns a copy of 'x' that has been clamped between the range 0 and 1.
HLML_INLINE int32_t saturatei( const int32_t x )
{
	return clampi( x, 0, 1 );
}

// Returns 1 if 'y' is greater than 'x', otherwise returns 0.
HLML_INLINE int32_t stepi( const int32_t x, const int32_t y )
{
	return ( y > x ? 1 : 0 );
}


// uint32_t
// Returns 'x' if it's smaller than 'y', otherwise returns 'y'.
HLML_INLINE uint32_t minu( const uint32_t x, const uint32_t y )
{
	return ( x < y ) ? x : y;
}

// Returns x if it's larger than 'y', otherwise returns 'y'.
HLML_INLINE uint32_t maxu( const uint32_t x, const uint32_t y )
{
	return ( x > y ) ? x : y;
}

// If 'x' is lower than 'low' or higher than 'high' then returns 'low' or 'high' respectively, otherwise returns 'x'.
HLML_INLINE uint32_t clampu( const uint32_t x, const uint32_t low, const uint32_t high )
{
	return minu( maxu( x, low ), high );
}

// Returns a copy of 'x' that has been clamped between the range 0 and 1.
HLML_INLINE uint32_t saturateu( const uint32_t x )
{
	return clampu( x, 0U, 1U );
}

// Returns 1 if 'y' is greater than 'x', otherwise returns 0.
HLML_INLINE uint32_t stepu( const uint32_t x, const uint32_t y )
{
	return ( y > x ? 1U : 0U );
}


// float
// Returns true if the two given floating-point numbers are close enough to each other within a user-specified margin of error to be considered equal.
HLML_INLINE bool floateq_eps( const float lhs, const float rhs, const float epsilon )
{
	return fabsf( lhs - rhs ) < epsilon;
}

// Returns true if the two given floating-point numbers are close enough to each other within margin of error `(float)( HLML_EPSILON )` to be considered equal.
HLML_INLINE bool floateq( const float lhs, const float rhs )
{
	return floateq_eps( lhs, rhs, (float)( HLML_EPSILON ) );
}

// Returns the given degrees to radians.
HLML_INLINE float radiansf( const float deg )
{
	return deg * (float)( HLML_PI ) / 180.0f;
}

// Returns the given radians to degrees.
HLML_INLINE float degreesf( const float rad )
{
	return rad * 180.0f / (float)( HLML_PI );
}

// Returns -1 if 'x' is < 0, 0 if 'x' == 0, or 1 if 'x' > 1.
HLML_INLINE int32_t signf( const float x )
{
	return ( 0.0f < x ) - ( x < 0.0f );
}

// Returns 'x' if it's smaller than 'y', otherwise returns 'y'.
HLML_INLINE float minf( const float x, const float y )
{
	return ( x < y ) ? x : y;
}

// Returns x if it's larger than 'y', otherwise returns 'y'.
HLML_INLINE float maxf( const float x, const float y )
{
	return ( x > y ) ? x : y;
}

// If 'x' is lower than 'low' or higher than 'high' then returns 'low' or 'high' respectively, otherwise returns 'x'.
HLML_INLINE float clampf( const float x, const float low, const float high )
{
	return minf( maxf( x, low ), high );
}

// Returns a copy of 'x' that has been clamped between the range 0 and 1.
HLML_INLINE float saturatef( const float x )
{
	return clampf( x, 0.0f, 1.0f );
}

// Returns a linearly interpolated float between 'a' and 'b', where 't' is the percentage (between 0 and 1) to interpolate by.
HLML_INLINE float lerpf( const float a, const float b, const float t )
{
	return ( 1.0f - t ) * a + t * b;
}

// Returns 1 if 'y' is greater than 'x', otherwise returns 0.
HLML_INLINE float stepf( const float x, const float y )
{
	return ( y > x ? 1.0f : 0.0f );
}

// Performs a sigmoid-like interpolation and clamp.
HLML_INLINE float smoothstepf( const float low, const float high, const float x )
{
	float t = saturatef( ( x - low ) / ( high - low ) );
	return t * t * ( 3.0f - 2.0f * t );
}

// Performs a 'smoother' version of smoothstep, as design by Ken Perlin.
// https://en.wikipedia.org/wiki/Smoothstep#Variations
HLML_INLINE float smootherstepf( const float low, const float high, const float x )
{
	float t = saturatef( ( x - low ) / ( high - low ) );
	return t * t * t * ( t * ( t * 6.0f - 15.0f ) + 10.0f );
}


// double
// Returns true if the two given floating-point numbers are close enough to each other within a user-specified margin of error to be considered equal.
HLML_INLINE bool doubleeq_eps( const double lhs, const double rhs, const double epsilon )
{
	return fabs( lhs - rhs ) < epsilon;
}

// Returns true if the two given floating-point numbers are close enough to each other within margin of error `( HLML_EPSILON )` to be considered equal.
HLML_INLINE bool doubleeq( const double lhs, const double rhs )
{
	return doubleeq_eps( lhs, rhs, ( HLML_EPSILON ) );
}

// Returns the given degrees to radians.
HLML_INLINE double radiansd( const double deg )
{
	return deg * ( HLML_PI ) / 180.0;
}

// Returns the given radians to degrees.
HLML_INLINE double degreesd( const double rad )
{
	return rad * 180.0 / ( HLML_PI );
}

// Returns -1 if 'x' is < 0, 0 if 'x' == 0, or 1 if 'x' > 1.
HLML_INLINE int32_t signd( const double x )
{
	return ( 0.0 < x ) - ( x < 0.0 );
}

// Returns 'x' if it's smaller than 'y', otherwise returns 'y'.
HLML_INLINE double mind( const double x, const double y )
{
	return ( x < y ) ? x : y;
}

// Returns x if it's larger than 'y', otherwise returns 'y'.
HLML_INLINE double maxd( const double x, const double y )
{
	return ( x > y ) ? x : y;
}

// If 'x' is lower than 'low' or higher than 'high' then returns 'low' or 'high' respectively, otherwise returns 'x'.
HLML_INLINE double clampd( const double x, const double low, const double high )
{
	return mind( maxd( x, low ), high );
}

// Returns a copy of 'x' that has been clamped between the range 0 and 1.
HLML_INLINE double saturated( const double x )
{
	return clampd( x, 0.0, 1.0 );
}

// Returns a linearly interpolated float between 'a' and 'b', where 't' is the percentage (between 0 and 1) to interpolate by.
HLML_INLINE double lerpd( const double a, const double b, const double t )
{
	return ( 1.0 - t ) * a + t * b;
}

// Returns 1 if 'y' is greater than 'x', otherwise returns 0.
HLML_INLINE double stepd( const double x, const double y )
{
	return ( y > x ? 1.0 : 0.0 );
}

// Performs a sigmoid-like interpolation and clamp.
HLML_INLINE double smoothstepd( const double low, const double high, const double x )
{
	double t = saturated( ( x - low ) / ( high - low ) );
	return t * t * ( 3.0 - 2.0 * t );
}

// Performs a 'smoother' version of smoothstep, as design by Ken Perlin.
// https://en.wikipedia.org/wiki/Smoothstep#Variations
HLML_INLINE double smootherstepd( const double low, const double high, const double x )
{
	double t = saturated( ( x - low ) / ( high - low ) );
	return t * t * t * ( t * ( t * 6.0 - 15.0 ) + 10.0 );
}


#ifdef __cplusplus
}
#endif
