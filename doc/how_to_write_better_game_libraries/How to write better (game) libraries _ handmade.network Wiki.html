<!DOCTYPE html>
<!-- saved from url=(0113)https://handmade.network/wiki/7138-how_to_write_better_game_libraries#instead,_you_could_do_the_following_things_ -->
<html lang="en-US"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    
    <link rel="canonical" href="https://handmade.network/wiki/7138-how_to_write_better_game_libraries">
    
        
            <meta property="og:site_name" content="Handmade.Network">
        
            <meta property="og:type" content="website">
        
            <meta property="og:image" content="http://handmade.network/static/media/projects/light-logo/projects/light-logo/hmn.png">
        
            <meta property="og:image:secure_url" content="https://handmade.network/static/media/projects/light-logo/projects/light-logo/hmn.png">
        
            <meta property="og:image:type" content="image/png">
        
            <meta property="og:image:width" content="400">
        
            <meta property="og:image:height" content="400">
        
            <meta property="og:title" content="How to write better (game) libraries | handmade.network Wiki">
        
            <meta property="og:description" content="Introduction
The aim of this article is to provide a series of good general advice and considerat…">
        
            <meta property="og:url" content="https://handmade.network/wiki/7138-how_to_write_better_game_libraries">
        
    
    <title>How to write better (game) libraries | handmade.network Wiki</title>
    <link href="./How to write better (game) libraries _ handmade.network Wiki_files/css" rel="stylesheet" type="text/css">
    <link href="./How to write better (game) libraries _ handmade.network Wiki_files/css(1)" rel="stylesheet" type="text/css">
    <link rel="stylesheet" type="text/css" href="./How to write better (game) libraries _ handmade.network Wiki_files/style.css"> 
    <style type="text/css">
        body {
        
            background-image:url("/_asset/bg/light/cd4e31.bmp");
            background-size:auto;
        
        }
    </style>
    
<script type="text/javascript" src="./How to write better (game) libraries _ handmade.network Wiki_files/util.js.download"></script>
<script type="text/javascript" src="./How to write better (game) libraries _ handmade.network Wiki_files/wiki.js.download"></script>

    <link rel="stylesheet" href="./How to write better (game) libraries _ handmade.network Wiki_files/theme.css">
    
    <link rel="stylesheet" href="./How to write better (game) libraries _ handmade.network Wiki_files/cd4e31.css">
    
    <link rel="apple-touch-icon" sizes="57x57" href="https://handmade.network/static/apple-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="60x60" href="https://handmade.network/static/apple-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="72x72" href="https://handmade.network/static/apple-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="76x76" href="https://handmade.network/static/apple-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="114x114" href="https://handmade.network/static/apple-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="120x120" href="https://handmade.network/static/apple-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="144x144" href="https://handmade.network/static/apple-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="152x152" href="https://handmade.network/static/apple-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="https://handmade.network/static/apple-icon-180x180.png">
    <link rel="icon" type="image/png" sizes="192x192" href="https://handmade.network/static/android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="https://handmade.network/static/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="https://handmade.network/static/favicon-96x96.png">
    <link rel="icon" type="image/png" sizes="16x16" href="https://handmade.network/static/favicon-16x16.png?v=2">
    <link rel="manifest" href="https://handmade.network/static/manifest.json">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="msapplication-TileImage" content="/static/ms-icon-144x144.png">
    <meta name="theme-color" content="#ffffff">
</head>

<body class="project wiki">
    <div class="content mw-site ph3-m ph4-l">
        

<header class="mb3">
    <div class="user-options flex justify-center justify-end-ns"><a class="register" id="register-link" href="https://handmade.network/_register">Register</a><a class="login" id="login-link">Log in</a><div id="login-popup"><form action="https://handmade.network/_login" method="post"><input type="hidden" name="csrfmiddlewaretoken" value="PGFFKXgrzDvCRdlCKU4gjyhmCOiDyXdZVfQMCzmdVm98l2MUP6K7TqhNveGTLbvC"><table><tbody><tr><th><label>Username:</label></th><td><input type="text" name="username" class="textbox username" value="" autocomplete="off" style="background-image: url(&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAASCAYAAABSO15qAAAAAXNSR0IArs4c6QAAAUBJREFUOBGVVE2ORUAQLvIS4gwzEysHkHgnkMiEc4zEJXCMNwtWTmDh3UGcYoaFhZUFCzFVnu4wIaiE+vvq6+6qTgthGH6O4/jA7x1OiCAIPwj7CoLgSXDxSjEVzAt9k01CBKdWfsFf/2WNuEwc2YqigKZpK9glAlVVwTTNbQJZlnlCkiTAZnF/mePB2biRdhwHdF2HJEmgaRrwPA+qqoI4jle5/8XkXzrCFoHg+/5ICdpm13UTho7Q9/0WnsfwiL/ouHwHrJgQR8WEwVG+oXpMPaDAkdzvd7AsC8qyhCiKJjiRnCKwbRsMw9hcQ5zv9maSBeu6hjRNYRgGFuKaCNwjkjzPoSiK1d1gDDecQobOBwswzabD/D3Np7AHOIrvNpHmPI+Kc2RZBm3bcp8wuwSIot7QQ0PznoR6wYSK0Xb/AGVLcWwc7Ng3AAAAAElFTkSuQmCC&quot;); background-repeat: no-repeat; background-attachment: scroll; background-size: 16px 18px; background-position: 98% 50%;"></td></tr><tr><th><label>Password:</label></th><td><input type="password" name="password" class="textbox password" value="" autocomplete="off" style="background-image: url(&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAASCAYAAABSO15qAAAAAXNSR0IArs4c6QAAAUBJREFUOBGVVE2ORUAQLvIS4gwzEysHkHgnkMiEc4zEJXCMNwtWTmDh3UGcYoaFhZUFCzFVnu4wIaiE+vvq6+6qTgthGH6O4/jA7x1OiCAIPwj7CoLgSXDxSjEVzAt9k01CBKdWfsFf/2WNuEwc2YqigKZpK9glAlVVwTTNbQJZlnlCkiTAZnF/mePB2biRdhwHdF2HJEmgaRrwPA+qqoI4jle5/8XkXzrCFoHg+/5ICdpm13UTho7Q9/0WnsfwiL/ouHwHrJgQR8WEwVG+oXpMPaDAkdzvd7AsC8qyhCiKJjiRnCKwbRsMw9hcQ5zv9maSBeu6hjRNYRgGFuKaCNwjkjzPoSiK1d1gDDecQobOBwswzabD/D3Np7AHOIrvNpHmPI+Kc2RZBm3bcp8wuwSIot7QQ0PznoR6wYSK0Xb/AGVLcWwc7Ng3AAAAAElFTkSuQmCC&quot;); background-repeat: no-repeat; background-attachment: scroll; background-size: 16px 18px; background-position: 98% 50%;"></td></tr><tr></tr></tbody></table><div class="actionbar pt2"><input type="submit" value="Log In"></div></form></div></div><div class="menu-bar flex flex-column flex-row-l justify-between "><div class="flex flex-column flex-row-ns"><a href="https://handmade.network/home" class="logo hmdev-logo"><div class="underscore"></div></a><div class="items flex items-center justify-center justify-start-ns"><a href="https://handmade.network/projects" class="projects">Projects</a><a href="https://handmade.network/blog" class="blogs">News</a><a href="https://handmade.network/forums" class="forums">Forums</a><a href="https://handmade.network/wiki" class="wiki">Wiki</a><a href="https://handmade.network/library" class="library">Library</a><a href="https://handmade.network/manifesto" class="misson">Mission</a></div></div><form class="dn ma0 flex-l flex-column justify-center items-end" method="post" action="https://handmade.network/_search" target="_blank"><input type="hidden" name="csrfmiddlewaretoken" value="PGFFKXgrzDvCRdlCKU4gjyhmCOiDyXdZVfQMCzmdVm98l2MUP6K7TqhNveGTLbvC"><input class="site-search bn lite pa2 fira" type="text" name="term" value="" placeholder="Search with Google" size="17"><input id="search_button_homepage" type="submit" value="Go"></form></div>
</header>

<script type="text/javascript">
    document.addEventListener("DOMContentLoaded", function() {
        var loginPopup = document.getElementById("login-popup");
        var loginLink = document.getElementById("login-link");

        if (loginPopup !== null) {
            loginLink.removeAttribute("href");

            loginLink.onclick = function() {
                loginPopup.classList.toggle("open");
            }
        }
    });
</script>

        

    <div class="top-bar ph3 ph0-ns">
        <a class="breadcrumb" href="https://handmade.network/">handmade.network</a>
         » 
        <a class="breadcrumb" href="https://handmade.network/wiki">Wiki</a>
         » 
        <a class="breadcrumb" href="https://handmade.network/wiki/7138-how_to_write_better_game_libraries">How to write better (game) libraries</a>
    </div>

<div class="flex flex-column flex-row-l">
    <div class="flex-grow-1 overflow-hidden">
        
            <div class="content-block">
                <div class="clear"></div>
                
 <div class="optionbar">
    
        <a class="button" href="https://handmade.network/wiki">← Back to home</a>
        
        
        <a class="button history" href="https://handmade.network/wiki/7138-how_to_write_better_game_libraries/history" title="History"><span class="big">⛕</span> Revision History</a>
        <a class="button talk" href="https://handmade.network/wiki/7138-how_to_write_better_game_libraries/talk" title="Talk"><span class="big">⚖</span> Talk</a>
    
 </div>
    <article class="post">
        <div class="body">
        <div class="contents">
            <h1 id="introduction">Introduction</h1>
<p>The aim of this article is to provide a series of good general advice and considerations on how to design and write libraries, particularly if portability, ease of use and performance are of concern. </p>

<p>The word "game" is in parentheses since most of the advice also applies to non-game libraries.</p>

<p>Bear in mind that there is no "true way" to write a library and different people have different opinions, however, there do exist general advice and considerations that can be examined based on existing work.</p>

<p>The advice and considerations presented in this article are not meant for all kinds of libraries, for example, for libraries such as language-specific containers or wrappers around os functionality, some of the advice may not apply. Remember that when designing a library you should understand your requirements and do what you find to be the best approach, this article acts simply as a non-exhaustive list of good considerations and advice.</p>

<p>This article aims to present advice based on existing libraries that are considered of quality in the community so that developers can better understand some of the considerations involved in designing a library. The list does not aim to be exhaustive, but hopefully, it can be updated to include more advice and considerations over time and serves as a starting point and educational resource to anyone interested in library design.</p>

<p>The core principles of this advice are:</p>

<ol>
<li><p>Maximize portability.</p></li>
<li><p>Be easy to build.</p></li>
<li><p>Be easy to integrate.</p></li>
<li><p>Be usable in as many scenarios as possible.</p></li>
</ol>
<h1 id="consider_writing_the_library_in_c_and_add_wrappers_to_other_languages_later.">Consider writing the library in C and add wrappers to other languages later.</h1><h3 id="c_is_the_lingua_franca_of_programming._there_are_many_advantages_to_writing_your_library_in_c_from_t">C is the lingua franca of programming. There are many advantages to writing your library in C from the start:</h3>
<ol>
<li><p>Every language out there has a way to call into C, so if you write your library in C everyone will be able to use it, in any language, and people can write wrappers for it easily. 
If you write a library in Python, chances are most people won’t be able to use it if they don’t also use Python. If you write a library in C however, someone who really likes it can make bindings for it in Python. C truly brings all of us together.</p></li>
<li><p>C code is usually fast. There is a saying that if your code is slower than C, someone will rewrite it in C. Performance is especially important for game developers and people who use low-level languages in general.</p></li>
<li><p>C is the most portable language in the world, if your library is written in C it means it can be used on any OS, console or mobile device and even on the web.</p></li>
</ol>
<h3 id="you_might_also_consider_writing_the_library_in_c++,_be_mindful_however_of_the_following_drawbacks_">You might also consider writing the library in C++, be mindful however of the following drawbacks:</h3>
<ol>
<li><p>It is easier in general for a C++ user to use a C library than it is for a C user to use a C++ library.</p></li>
<li><p>C++ is not as easy to write wrappers for in other languages.</p></li>
<li><p>If you use C++, unless you limit which C++ features you use (to the point where you are pretty much left with C) a lot of people won’t be able to use your library. Not everyone uses RAII, some people disable exceptions and RTTI, and not everyone is willing to use a library with smart pointers, template metaprogramming, STL allocators, virtual dispatch, etc.</p></li>
</ol>
<h3 id="take_into_account_the_following_aspects_when_writing_your_c_library_">Take into account the following aspects when writing your C library:</h3>
<ol>
<li><p>Compiler extensions make your code less portable, try using the subset of C99 which compiles both in C and C++ mode on GCC, Clang, and MSVC. This is important since some compilers (such as MSVC) have problems with supporting C.</p></li>
<li><p>Try not to use the hosted (OS-dependent) parts of the C standard library, unless you really have to, since they might work differently on other platforms (or might not work at all). If you need to use OS-dependent functions but want to maximize portability, request function pointers from the client.</p></li>
<li><p>Prefix your names to avoid name collisions (more on this later).</p></li>
<li><p>For maximum portability consider using the built-in C types (<code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>). This is because not all compilers and platforms have support for <code>stdint.h</code> (eg: old versions of MSVC). Try checking for the availability of <code>stdint.h</code> and use that if available. As an example consider looking at how the library <code>stb_image</code> handles the use of <code>stdint.h</code>.</p></li>
<li><p>Consider using header guards instead of <code>#pragma once</code>. Header guards are standard and also allow the user of the library to check if a library was included.</p></li>
<li><p>Undef macros that should not be exposed to the user at the end (eg: <code>my_min/max</code> macros), do this even in C files.</p></li>
<li><p>Make sure your library can compile as one compilation unit since a lot of developers choose to do single-compilation-unit builds (also known as unity builds).</p></li>
</ol>
<h3 id="if_you_want_to_use_another_language_for_the_implementation,_consider_keeping_the_interface_in_c.">If you want to use another language for the implementation, consider keeping the interface in C.</h3>
<p>If you want to write a library using another language, such as Odin, Rust, Zig, C++, etc, consider keeping the interface in C so that people can easily use it and wrap it for other languages.</p>

<p>Bear in mind that this has several disadvantages: </p>

<ol>
<li><p>People might have a harder time integrating your library into their projects as source.</p></li>
<li><p>You might be adding the standard library of your language of choice as an extra dependency that the user of your library now needs to consider. This can also have other implications, for example, some standard libraries use the general heap allocator, which violates the principle of giving the user of the library full control over memory allocations (more on this later). Also interfacing with certain aspects of a standard library from another language via a C API could be awkward.</p></li>
<li><p>You might need to provide precompiled binaries or ways for your users to build your library for their target platform. This might not be an issue with C++ but it can be with other languages (eg: Odin, Zig, Rust).</p></li>
<li><p>If people don't use the same language for their projects their debugging experience might suffer when using your library.</p></li>
</ol>
<h1 id="consider_providing_an_optional_c++_wrapper.">Consider providing an optional C++ wrapper.</h1>
<p>Besides C users, C++ users are the ones most likely to use your C library. To that extent, you might want to consider making their experience better by providing a C++ wrapper.</p>

<p>Take into consideration that this is an extra piece of code you would have to maintain but that can help the adoption of your library by C++ developers.</p>
<h2 id="basic_things_you_can_do_when_writing_your_c++_wrapper_">Basic things you can do when writing your C++ wrapper:</h2>
<ol>
<li><p>Use .hpp and .cpp for your C++ wrapper to distinguish between the C and C++ code. Consider putting the C++ wrapper in another folder or repo and mention it in the readme.</p></li>
<li><p>Try not to include the header from the C version in the hpp file. Instead, rewrite the declarations in the hpp in a more C++ style and in the cpp file include the C header and provide the definitions for all the wrapper functions. This is to prevent the names from C and macros to spill into C++ code.</p></li>
<li><p>Expose constants to the user using constexpr variables. This is especially easy since C structs are constexpr by default. Make sure constants from C that use macros are not present in the C++ wrapper.</p></li>
<li><p>Use namespaces and wrap all the functions like so <code>namespace mylib { foo bar() { return mylib_bar(); }</code>.</p></li>
<li><p>Try not to use exceptions and RTTI. Especially in game development, not all people use them and some just disable them.</p></li>
<li><p>Consider using default parameter values over function wrappers. C lacks default values for parameters so usually, people write a function with a lot of parameters and then create several wrappers for it that calls the original function with different default parameter values. C++ has default parameter values so consider removing the extra wrapper functions if you have any.</p></li>
<li><p>Try not to use STL containers or smart pointers since your wrapper should just simply wrap the functions from C and also adding those that bring extra problems that you need to consider. (More on this later)</p></li>
<li><p>If you decide to offer RAII wrappers for parts of your library, still provide wrappers for the non-RAII structs and functions. This is important because not all developers use RAII and if you don’t expose the non-RAII versions of structs and functions in your C++ layer they won’t be able to use it, at least not fully.</p></li>
</ol>
<h1 id="try_not_to_make_the_use_of_a_build_system_mandatory.">Try not to make the use of a build system mandatory.</h1>
<p>There are many build systems out there and chances are people won’t use the same one you do. If your library simply presents the source files, the header files and a list of the dependencies (if you have any), this will help developers integrate your library into their projects.</p>

<p>If there are compiler flags needed to compile your library then you can mention them in the readme, though preferably there won’t be any.</p>

<p>It is good to include optional build files, but mention in the readme that they are optional and try to keep the simple structure that lets people integrate the library easily with their preferred build system.</p>

<p>If you do use a build system such as CMake or Make, try to use them in a standard way so that developers who choose to use them can get the most out of them.</p>
<h1 id="ensure_that_people_can_easily_compile_the_library_from_source.">Ensure that people can easily compile the library from source.</h1>
<p>Distribute your libraries such that people can simply include the source files in their project and be done with it.</p>
<h3 id="this_has_many_advantages_such_as_">This has many advantages such as:</h3>
<ol>
<li><p>Letting people easily reason about your library. </p></li>
<li><p>Easy to include in cross-platform projects, no craziness regarding libc versions and platform stuff.</p></li>
<li><p>It allows people to step through the code in a debugger.</p></li>
</ol>
<h1 id="minimize_dependencies.">Minimize dependencies.</h1>
<p>If your library has dependencies, try to list them in a file (such as the readme) so that users can easily reason about them.
Also, try to only use dependencies if absolutely necessary. Don’t get a dependency if you only use 1 - 3 functions from it since that adds bloat. Instead, consider writing your own version or extracting those functions you need from another library into your own. For example, if you need some light text manipulation functions then consider writing your own instead of adding a dependency, but if you need to parse a JSON file, a well-tested library might be worth using instead of trying to implement your own. </p>

<p>Try not to fall into the trap of using a library for every single small thing (eg: see is-odd and is-even from NPM).</p>

<p>The more dependencies you have the harder it will be for the user to decide whether they should use your library because they now have to consider all of your dependencies as well.</p>
<h1 id="try_not_to_allocate_memory_for_the_user.">Try not to allocate memory for the user.</h1>
<p>Many developers, especially in game dev and low-level software development, have custom memory allocation strategies and do not use the general heap allocator (malloc/free).
If a library allocates memory using the general-purpose heap allocator then certain developers might not be able to use it.</p>

<p>To make the experience better for them, consider asking for buffers or allocators from the user instead of calling malloc/free yourself and use stack-allocated buffers (up to one or more kb) for small temporary operations (eg: some string manipulation).</p>

<p>Also, if you decide to write your library in C++, using STL containers, without a way for developers to specify the allocator, this would also make it unusable for them, which is another reason to prefer C99 and write the C++ wrapper afterward.</p>

<p>If your library needs to do a lot of extra work and has a lot of tiny allocations that can occur (such as for temporary allocations when doing string manipulation), consider asking the user for a buffer or an allocator for temporary memory.</p>

<p>In C++ you can use default parameters for functions that ask for an allocator to use the heap allocator by default. You can also overload functions to have a version that allocates the memory for the user.</p>
<h1 id="be_const_correct.">Be const correct.</h1>
<p>Some developers use const, some don’t.
If you don’t use const for the function parameters in your functions however, this will only negatively affect developers who use choose to use const. So use const for pointers to data that you intend to only read from.
Being const correct also helps with documenting code, it even helps developers who don’t use const.</p>
<h1 id="always_ask_for_the_size_of_buffers_even_for_const_char*">Always ask for the size of buffers (even for const char*)</h1>
<p>Since we mentioned custom allocators and asking for buffers instead of allocating memory using the heap allocator, remember to always ask the user for the size of the provided buffer.
Even if the buffer you receive is expected to have a sentinel value (such as a null terminator) still ask for the size of the buffer. The reason is, in game development and other high-performance software, we often pack buffers together in memory for efficiency reasons, so going out of the bounds of a buffer might not result in a crash from a memory access violation and this is a very hard to catch bug.
Also, not all users use null-terminated strings all the time (for a variety of reasons). If you must use a null-terminated string, such as when interfacing with an OS function, consider informing the user about this and still maybe ask for the buffer size.</p>

<p>When dealing with strings also bear in mind that buffer size and string size are different, since the string size doesn’t take into consideration the null terminator, so specify in comments and documentation if the user should provide the buffer size or the string size when asking for a <code>const char*</code>.</p>

<p>Additionally, you can provide convenience functions that ask for a C Null Terminated String and invoke <code>strlen</code> to get the size and pass it to the function they wrap.</p>
<h1 id="try_not_to_handle_resources_for_user.">Try not to handle resources for user.</h1>
<p>Write your library such that a user can simply pass everything that it needs to it and then it gives the user back what they wanted. If your library needs something, consider asking the user for it instead of trying to get that thing on your own.</p>

<p>Try not to handle memory or other resources in a way that is invisible to the user since they might encounter problems if the way you manage that resource is incompatible with that they are doing.</p>

<p>Consider offering optional versions of your functions that handle resources or allocate resources on behalf of the user. The user might want to use those (if it’s possible in their case) or at the very least they can use those to test out the library.</p>
<h1 id="avoid_using_os-dependent_functions_such_as_fopen_for_maximum_portability.">Avoid using os-dependent functions (such as fopen) for maximum portability.</h1>
<p>This might sound weird but sadly <code>fopen</code> and many other os-dependent functions don't work as intended on all platforms that a game dev might want to support. </p>

<p>For example, on Android, you need to use <code>AAssetManager</code> for assets and <code>fopen</code> for internal storage. Because of this, in order to use libraries that need <code>fopen</code> on Android, some devs do stuff like <code>#define fopen</code> which is really hacky and error-prone.
Also depending on the project, IO must be handled in different ways (eg: memory-mapped files, async IO).</p>
<h3 id="instead,_you_could_do_the_following_things_">Instead, you could do the following things:</h3>
<ol>
<li><p>Ask for buffers to the file data and let the client of the library do the IO.</p></li>
<li><p>Ask for function pointers for IO operations that the client of the library needs to provide.</p></li>
<li><p>Offer optional variants of those functions that use fopen, most games are tested and developed on Windows or Linux where such functions can be used to integrate the library into the game quickly for testing purposes.</p></li>
</ol>

<p>In general, if you are unsure about the availability and support of a os-dependent function in libc and don’t want to have to manually provide support for every single platform that users might need (especially if you only need a few os-dependent functions), consider asking the user for function pointers to functions that achieve the goal of that os-dependent function. This maximizes your portability and it is simple for your users to do.</p>
<h1 id="don’t_load_opengl_in_the_library_if_you_depend_on_it.">Don’t load OpenGL in the library if you depend on it.</h1>
<p>If your library depends on OpenGL then don’t include any OpenGL headers and don’t try to load OpenGL yourself.
Sadly OpenGL needs to be loaded very differently on each platform and it’s hard to load it without essentially enforcing a platform layer and maintaining it for all platforms. Not to mention on some platforms there are multiple, mutually exclusive ways to load OpenGL and depending on the scenario a game dev might use one over the other.</p>

<p>If your library handles OpenGL loading by itself then people can’t use it, not without having to fork it to remove your custom OpenGL loading code. Depending on another library which also does this is also bad.</p>

<p>In your code, don’t include any OpenGL headers. Instead, specify in the readme which version of OpenGL you use and tell users which .c files need OpenGL. 
What they can then do is wrap those files like such:</p>
<div class="code"><table class="cpp codeblocktable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="cpp codeblock"><pre><span></span><span class="c1">// library_file_that_uses_opengl.c</span>
<span class="cp">#include</span> <span class="cpf">&lt;my_opengl&gt; // Include a header with OpenGL definitions that works for my game</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;library/file_that_uses_opengl.c&gt;</span><span class="cp"></span>
</pre></div>
</td></tr></tbody></table></div>
<p>This way users can compile your library which uses OpenGL and have it work with how they load OpenGL in their game.</p>

<p>For DirectX and Metal, there are standard headers and you can check if the user defined a flag like <code>MYLIB_USE_DIRECTX</code> or <code>MYLIB_USE_METAL</code> and include those headers based on that. 
For Vulkan, I think you need to do the same thing as with OpenGL.</p>

<p>For an example of this pattern take a look at <a href="https://github.com/floooh/sokol/blob/master/sokol_gfx.h">sokol_gfx</a></p>

<p>For higher portability when writing rendering code, consider using the subset of OpenGL from OpenGL ES 3, unless you are willing to provide multiple versions of your graphics code.</p>

<p>If possible, offer support for multiple graphics backends like DirectX and Metal. If you can only focus on adding one extra backend prefer Metal since OpenGL is deprecated on iOS and macOS. When writing the code for multiple different graphics backends or API versions, consider splitting the rendering code into different files depending on the backend and API version (eg: Project files: <code>my_lib.h, my_lib_opengles2.c, my_lib_opengl4.c, my_lib_metal.c</code>).</p>
<h1 id="provide_examples.">Provide examples.</h1>
<p>Examples are a great way for people to get to know your library. </p>

<ol>
<li><p>Providing a folder with easy to compile 1-2 file example source code is amazing.</p></li>
<li><p>Providing examples in the comments is awesome.</p></li>
<li><p>Providing examples in the readme is great.</p></li>
<li><p>Providing a Github wiki (though not necessary for most projects) is god-like.</p></li>
</ol>

<p>If your library is easy to understand and easy to compile that increases the chances of anyone using it exponentially.</p>

<p>Another advantage of a suite of examples is that it can serve a double purpose as a testing suite. If you have lots of examples you can use them to validate that your library still works correctly. This is especially important for libraries that do rendering since you can’t normally unit test that.</p>
<h1 id="use_namespace_prefixes.">Use namespace prefixes.</h1>
<p>Prefix any exported symbol like such <code>mylib_</code> to avoid naming collisions. This includes macros, enum constants, function/struct names. 
Do this in the .c file as well since some people do single-compilation-unit builds. Consider using a different naming convention for internal functions that should not be exposed to the user (eg: <code>mylib_impl_</code> or <code>mylib__</code>), this helps people who do single-compilation-unit builds.</p>
<h1 id="avoid_global_variables_if_possible.">Avoid global variables if possible.</h1>
<p>There are moments when global variables are appropriate, such as for static data that must be available to the library. Global variables are not always the worst thing, and most people can tolerate them depending on their use (sometimes they even make the API easier to use). </p>
<h3 id="but_try_to_keep_them_to_a_minimum_in_general_as_they_can_have_implications_">But try to keep them to a minimum in general as they can have implications:</h3>
<ol>
<li><p>What if the user tries to use your library on multiple threads?</p></li>
<li><p>Many people do hot reloading by compiling the game code into a DLL that gets refreshed on recompile while the game executable still runs. When they do this all global variables are reset. This means they can’t use your library in game code if they do hot reloading.</p></li>
</ol>
<h1 id="consider_what_error_handling_strategy_you_will_use.">Consider what error handling strategy you will use.</h1>
<p>There are many ways to handle errors in C and there isn't just one standard way, take careful consideration as to what error handling mechanism you will use. 
It is also important to distinguish between real errors and precondition/invariant/postcondition violations.</p>
<h3 id="precondition,_invariant_and_postcondition_violations_are_not_errors.">Precondition, invariant and postcondition violations are not errors.</h3>
<p>These are usually bugs, and it is best to handle them using assertions. 
Use a macro like <code>#define MYLIB_ASSERT(condition, msg) assert(condition)</code> which is set by default to the libc assert but that the user of the library can modify to better fit their needs or to disable assertions for performance.</p>

<p>Don’t offer error handling unless there is actually an error to recover from.</p>

<p>Debuggers can catch assertion failures and the developer can see the stack trace.</p>

<p>Additionally, messages and comments regarding what triggered the assert are great, do those.</p>
<h3 id="consider_error_codes_or_result_structs_for_errors_that_must_be_handled_at_runtime_by_the_user">Consider error codes or result structs for errors that must be handled at runtime by the user</h3>
<p>If you do something that can fail and that needs to be handled by the client of the library (eg: you try to send a package over the internet but it fails) then simply return error codes (preferably enum constants) to the user. If you have additional information that is important to the user for the goal of handling the error then return a struct with the error code and extra data, but this is usually not the case.
This is often the most popular and simple choice for error handling in C.</p>

<p>Example:</p>
<div class="code"><table class="cpp codeblocktable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="cpp codeblock"><pre><span></span><span class="n">ParsePNGFileResult</span> <span class="n">result</span> <span class="o">=</span> <span class="n">ParsePNGFile</span><span class="p">(</span><span class="n">png_file_data</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* handle error */</span> <span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div><h3 id="consider_keeping_error_information_in_handles_context_structs">Consider keeping error information in handles/context structs</h3>
<p>For a series of functions that use a handle or a context struct, you might want to consider including the error in the handle and return early instead of asserting if an error is set in the handle/context struct. This gives users maximum flexibility because they can either check for an error after every single function call (like with returning error codes) or they can execute a full code path and check for errors at the end.</p>

<p>Example:</p>
<div class="code"><table class="cpp codeblocktable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="cpp codeblock"><pre><span></span><span class="n">FileHandle</span> <span class="n">file</span> <span class="o">=</span> <span class="n">OpenFile</span><span class="p">(</span><span class="n">file</span><span class="p">);</span> <span class="c1">//The file handle could be invalid after this, that information is stored in the file handle</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">GetDataFromFile</span><span class="p">(</span><span class="n">file</span><span class="p">);</span> <span class="c1">//If the file handle is invalid the function just returns NULL</span>
<span class="n">DoStuffWithData</span><span class="p">(</span><span class="n">data</span><span class="p">);</span> <span class="c1">// Note that if data is null the function just returns and does nothing</span>
<span class="n">CloseFile</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">CheckError</span><span class="p">(</span><span class="n">file</span><span class="p">))</span> <span class="p">{</span> <span class="cm">/* handle error */</span> <span class="p">}</span>
</pre></div>
</td></tr></tbody></table></div>
<p>In this example, the user had the option to either handle the error after an individual function call or at the end of the full code path. This pattern is used by many developers and by designing your library’s error handling this way you can satisfy both people who want to handle errors at the call site and people who want to handle it later on.</p>

<p>Here is an example of how you can refactor that code to check the error at the call site:</p>
<div class="code"><table class="cpp codeblocktable"><tbody><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="cpp codeblock"><pre><span></span><span class="n">FileHandle</span> <span class="n">file</span> <span class="o">=</span> <span class="n">OpenFile</span><span class="p">(</span><span class="n">file</span><span class="p">);</span> <span class="c1">//The file handle could be invalid after this, that information is stored in the file handle</span>
<span class="k">if</span> <span class="p">(</span><span class="n">CheckError</span><span class="p">(</span><span class="n">file</span><span class="p">))</span> <span class="p">{</span> <span class="cm">/* handle error */</span> <span class="p">}</span>
<span class="p">...</span>
</pre></div>
</td></tr></tbody></table></div>
<p>Note that when you compare this example to the one where we returned an error code it is not that different, but in practice this makes error handling much more flexible when dealing with handles or context structs. </p>

<p>It is important to remember however that this method only works when you have a handle or a context struct, if your function has no context or handle then consider using an error return value.</p>
<h3 id="other_error_handling_techniques">Other error handling techniques</h3>
<p>There are many other error handling techniques available. If you find other techniques to be more appropriate for your use case consider those. The ones mentioned above are merely some of the more popular options. Other options include <code>errno</code>, error handlers, exceptions (in C++).</p>
<h1 id="consider_your_distribution_model.">Consider your distribution model.</h1>
<p>Libraries like STB popularised the idea of Header Only Libraries due to the following factors:</p>

<ol>
<li><p>They are easy to build.</p></li>
<li><p>They are easy to include in a project.</p></li>
<li><p>They are easy to share and reason about because there is only one file.</p></li>
</ol>

<p>However, when deciding how to distribute your library consider the following drawbacks that a single header library could have as well:</p>

<ol>
<li><p>Header only libs can lead to longer compilation times because the whole file needs to be included even if the implementation is then discarded.</p></li>
<li><p>Some people prefer the implementation and interface to be kept separate for organizational and build other purposes.</p></li>
<li><p>It’s not much harder to do header + source than it is to do header only.</p></li>
</ol>

<p>At the end of the day keeping your library header-only will probably not be a deal-breaker, but as with everything, make sure to take pros and cons into consideration.</p>
<h1 id="conclusion">Conclusion</h1>
<p>Most of the advice presented in this article is based on feedback from the community and analysis of some of the most popular C libraries used by developers. 
Take into consideration that many people will have different opinions and this is ok. The article is meant to be a collection of advice and considerations based on the analysis of existing libraries. It is meant to be a starting point for people interested in developing libraries and the considerations that they might have to take when writing them.</p>
<h3 id="you_can_check_out_libraries_analyzed_for_this_article_here_">You can check out libraries analyzed for this article here:</h3>
<ol>
<li><p>Sokol libraries (graphics, platform layer, audio, net): <a href="https://github.com/floooh/sokol">https://github.com/floooh/sokol</a></p></li>
<li><p>BGFX (graphics): <a href="https://github.com/bkaradzic/bgfx">https://github.com/bkaradzic/bgfx</a></p></li>
<li><p>STB libraries (asset loading, utilities): <a href="https://github.com/nothings/stb">https://github.com/nothings/stb</a></p></li>
<li><p>Cute<em>headers (graphics, net, io, utilities, etc): <a href="https://github.com/RandyGaul/cute">https://github.com/RandyGaul/cute</a></em>headers </p></li>
<li><p>CGLTF (glTF loading): <a href="https://github.com/jkuhlmann/cgltf">https://github.com/jkuhlmann/cgltf</a></p></li>
<li><p>DR Libs (audio loading): <a href="https://github.com/mackron/dr_libs">https://github.com/mackron/dr_libs</a></p></li>
<li><p>Mini audio (audio playback): <a href="https://github.com/dr-soft/miniaudio">https://github.com/dr-soft/miniaudio</a></p></li>
<li><p>Par headers (graphics, utilities, etc): <a href="https://github.com/prideout/par">https://github.com/prideout/par</a></p></li>
<li><p>Physac (physics): <a href="https://github.com/victorfisac/Physac">https://github.com/victorfisac/Physac</a></p></li>
<li><p>Dear Imgui (ui): <a href="https://github.com/ocornut/imgui">https://github.com/ocornut/imgui</a></p></li>
<li><p>Soloud (audio): <a href="https://github.com/jarikomppa/soloud">https://github.com/jarikomppa/soloud</a></p></li>
<li><p>Meow Hash (non-crypto hash): <a href="https://github.com/cmuratori/meow_hash">https://github.com/cmuratori/meow_hash</a></p></li>
</ol>

<p>More to be added...</p>

        </div>
        </div>
    </article>

                
            </div>
        
    </div>
    <div class="sidebar flex-shrink-0 mw6 w-30-l self-center self-start-l mh3 mh0-ns ml3-l overflow-hidden">
        
<div class="content-block toc">
    <span class="title">Contents</span>
    <ul><li><a href="https://handmade.network/wiki/7138-how_to_write_better_game_libraries#introduction"><span class="toc-number">1.</span> Introduction</a></li><li><a href="https://handmade.network/wiki/7138-how_to_write_better_game_libraries#consider_writing_the_library_in_c_and_add_wrappers_to_other_languages_later."><span class="toc-number">2.</span> Consider writing the library in C and add wrappers to other languages later.</a></li><ul><ul><li><a href="https://handmade.network/wiki/7138-how_to_write_better_game_libraries#c_is_the_lingua_franca_of_programming._there_are_many_advantages_to_writing_your_library_in_c_from_t"><span class="toc-number">2.0.1.</span> C is the lingua franca of programming. There are many advantages to writing your library in C from the start:</a></li><li><a href="https://handmade.network/wiki/7138-how_to_write_better_game_libraries#you_might_also_consider_writing_the_library_in_c++,_be_mindful_however_of_the_following_drawbacks_"><span class="toc-number">2.0.2.</span> You might also consider writing the library in C++, be mindful however of the following drawbacks:</a></li><li><a href="https://handmade.network/wiki/7138-how_to_write_better_game_libraries#take_into_account_the_following_aspects_when_writing_your_c_library_"><span class="toc-number">2.0.3.</span> Take into account the following aspects when writing your C library:</a></li><li><a href="https://handmade.network/wiki/7138-how_to_write_better_game_libraries#if_you_want_to_use_another_language_for_the_implementation,_consider_keeping_the_interface_in_c."><span class="toc-number">2.0.4.</span> If you want to use another language for the implementation, consider keeping the interface in C.</a></li></ul></ul><li><a href="https://handmade.network/wiki/7138-how_to_write_better_game_libraries#consider_providing_an_optional_c++_wrapper."><span class="toc-number">3.</span> Consider providing an optional C++ wrapper.</a></li><ul><li><a href="https://handmade.network/wiki/7138-how_to_write_better_game_libraries#basic_things_you_can_do_when_writing_your_c++_wrapper_"><span class="toc-number">3.1.</span> Basic things you can do when writing your C++ wrapper:</a></li></ul><li><a href="https://handmade.network/wiki/7138-how_to_write_better_game_libraries#try_not_to_make_the_use_of_a_build_system_mandatory."><span class="toc-number">4.</span> Try not to make the use of a build system mandatory.</a></li><li><a href="https://handmade.network/wiki/7138-how_to_write_better_game_libraries#ensure_that_people_can_easily_compile_the_library_from_source."><span class="toc-number">5.</span> Ensure that people can easily compile the library from source.</a></li><ul><ul><li><a href="https://handmade.network/wiki/7138-how_to_write_better_game_libraries#this_has_many_advantages_such_as_"><span class="toc-number">5.0.1.</span> This has many advantages such as:</a></li></ul></ul><li><a href="https://handmade.network/wiki/7138-how_to_write_better_game_libraries#minimize_dependencies."><span class="toc-number">6.</span> Minimize dependencies.</a></li><li><a href="https://handmade.network/wiki/7138-how_to_write_better_game_libraries#try_not_to_allocate_memory_for_the_user."><span class="toc-number">7.</span> Try not to allocate memory for the user.</a></li><li><a href="https://handmade.network/wiki/7138-how_to_write_better_game_libraries#be_const_correct."><span class="toc-number">8.</span> Be const correct.</a></li><li><a href="https://handmade.network/wiki/7138-how_to_write_better_game_libraries#always_ask_for_the_size_of_buffers_even_for_const_char*"><span class="toc-number">9.</span> Always ask for the size of buffers (even for const char*)</a></li><li><a href="https://handmade.network/wiki/7138-how_to_write_better_game_libraries#try_not_to_handle_resources_for_user."><span class="toc-number">10.</span> Try not to handle resources for user.</a></li><li><a href="https://handmade.network/wiki/7138-how_to_write_better_game_libraries#avoid_using_os-dependent_functions_such_as_fopen_for_maximum_portability."><span class="toc-number">11.</span> Avoid using os-dependent functions (such as fopen) for maximum portability.</a></li><ul><ul><li><a href="https://handmade.network/wiki/7138-how_to_write_better_game_libraries#instead,_you_could_do_the_following_things_"><span class="toc-number">11.0.1.</span> Instead, you could do the following things:</a></li></ul></ul><li><a href="https://handmade.network/wiki/7138-how_to_write_better_game_libraries#don%E2%80%99t_load_opengl_in_the_library_if_you_depend_on_it."><span class="toc-number">12.</span> Don’t load OpenGL in the library if you depend on it.</a></li><li><a href="https://handmade.network/wiki/7138-how_to_write_better_game_libraries#provide_examples."><span class="toc-number">13.</span> Provide examples.</a></li><li><a href="https://handmade.network/wiki/7138-how_to_write_better_game_libraries#use_namespace_prefixes."><span class="toc-number">14.</span> Use namespace prefixes.</a></li><li><a href="https://handmade.network/wiki/7138-how_to_write_better_game_libraries#avoid_global_variables_if_possible."><span class="toc-number">15.</span> Avoid global variables if possible.</a></li><ul><ul><li><a href="https://handmade.network/wiki/7138-how_to_write_better_game_libraries#but_try_to_keep_them_to_a_minimum_in_general_as_they_can_have_implications_"><span class="toc-number">15.0.1.</span> But try to keep them to a minimum in general as they can have implications:</a></li></ul></ul><li><a href="https://handmade.network/wiki/7138-how_to_write_better_game_libraries#consider_what_error_handling_strategy_you_will_use."><span class="toc-number">16.</span> Consider what error handling strategy you will use.</a></li><ul><ul><li><a href="https://handmade.network/wiki/7138-how_to_write_better_game_libraries#precondition,_invariant_and_postcondition_violations_are_not_errors."><span class="toc-number">16.0.1.</span> Precondition, invariant and postcondition violations are not errors.</a></li><li><a href="https://handmade.network/wiki/7138-how_to_write_better_game_libraries#consider_error_codes_or_result_structs_for_errors_that_must_be_handled_at_runtime_by_the_user"><span class="toc-number">16.0.2.</span> Consider error codes or result structs for errors that must be handled at runtime by the user</a></li><li><a href="https://handmade.network/wiki/7138-how_to_write_better_game_libraries#consider_keeping_error_information_in_handles_context_structs"><span class="toc-number">16.0.3.</span> Consider keeping error information in handles/context structs</a></li><li><a href="https://handmade.network/wiki/7138-how_to_write_better_game_libraries#other_error_handling_techniques"><span class="toc-number">16.0.4.</span> Other error handling techniques</a></li></ul></ul><li><a href="https://handmade.network/wiki/7138-how_to_write_better_game_libraries#consider_your_distribution_model."><span class="toc-number">17.</span> Consider your distribution model.</a></li><li><a href="https://handmade.network/wiki/7138-how_to_write_better_game_libraries#conclusion"><span class="toc-number">18.</span> Conclusion</a></li><ul><ul><li><a href="https://handmade.network/wiki/7138-how_to_write_better_game_libraries#you_can_check_out_libraries_analyzed_for_this_article_here_"><span class="toc-number">18.0.1.</span> You can check out libraries analyzed for this article here:</a></li></ul></ul></ul>
</div>

    </div>
</div>

        
<footer class="pa3 pa4-l">
    <h2>
         Community by 
        <a href="https://handmade.network/home">handmade.network</a>
    </h2>
    <ul class="list">
        
            
<li class="ma0 pa0 dib-ns">
	
		
			
		
		<a href="https://handmade.network/about">About</a>
	
</li>

            
<li class="ma0 pa0 dib-ns">
	
		
			
		
		<a href="https://handmade.network/code-of-conduct">Code of Conduct</a>
	
</li>

            
<li class="ma0 pa0 dib-ns">
	
		
			
		
		<a href="https://handmade.network/communication-guidelines">Communication Guidelines</a>
	
</li>

            
<li class="ma0 pa0 dib-ns">
	
		
			
		
		<a href="https://handmade.network/contact">Contact</a>
	
</li>

            
<li class="ma0 pa0 dib-ns">
	
		
			
		
		<a href="https://handmade.network/sitemap">Sitemap</a>
	
</li>

        
    </ul>
</footer>

    </div>



</body></html>